<!doctype html>
<html lang="da">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Dead Man’s Draw – D&D Tavern (Steal & Swap)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  .tavern{background:
    radial-gradient(1200px 600px at 50% 20%,rgba(255,220,160,.08),transparent),
    radial-gradient(600px 300px at 10% 10%,rgba(255,255,255,.05),transparent),
    #0b0f17;min-height:100vh}
  .wood{background:
    radial-gradient(closest-side,rgba(0,0,0,.2),rgba(0,0,0,.5)),
    repeating-conic-gradient(from 0deg,#5d3a1a 0 10deg,#6f4621 10deg 20deg);
    border:8px solid #3d2a13;box-shadow:0 0 40px rgba(0,0,0,.6) inset,0 10px 30px rgba(0,0,0,.6)}
  .circle{position:relative;width:520px;height:520px;border-radius:50%;margin:0 auto}
  .seat{position:absolute;width:140px;height:160px;transform:translate(-50%,-50%)}
  .card{width:48px;height:70px;border-radius:8px;border:2px solid rgba(0,0,0,.6);
    box-shadow:0 2px 8px rgba(0,0,0,.5);background:linear-gradient(135deg,#222,#333);
    transition:transform .12s ease, box-shadow .12s ease, outline .12s ease; cursor:default}
  .card.me-turn{cursor:pointer}
  .life{background:linear-gradient(135deg,#164e63,#0e7490)!important}
  .death{background:linear-gradient(135deg,#3f1d1d,#7f1d1d)!important}
  .selected{outline:3px solid #fbbf24; box-shadow:0 0 18px rgba(251,191,36,.55)}
  .targetable{outline:2px dashed #60a5fa}
  .token{width:28px;height:28px;border-radius:50%;background:radial-gradient(circle at 30% 30%,#ffe38a,#b88700);
    border:2px solid #4a3406;box-shadow:0 1px 6px rgba(0,0,0,.6);display:inline-flex;align-items:center;justify-content:center;
    font-weight:700;font-size:12px;color:#3a2a02}
  .scrollbox{scrollbar-color:#334155 transparent}
  .rules a{color:#93c5fd;text-decoration:underline}
  .pill{display:inline-block;padding:.2rem .5rem;border-radius:9999px;border:1px solid #334155;background:#0f172a;color:#e2e8f0;font-size:.75rem}

  .opp-card-hit { cursor: pointer; padding: 4px; }
  .opp-card-hit.targetable:hover { transform: scale(1.04); box-shadow: 0 0 18px rgba(96,165,250,.45); outline: 2px solid #60a5fa; }

  #swap-chooser { position:absolute; left:50%; transform:translateX(-50%); bottom:-8px; background:rgba(15,23,42,.95);
    border:1px solid #334155; border-radius:12px; padding:.5rem; display:none; min-width:220px; box-shadow:0 8px 24px rgba(0,0,0,.5); }
  #swap-chooser.show { display:block; }
  #swap-chooser .opt { padding:.35rem .6rem; border:1px solid #334155; border-radius:10px; display:flex; align-items:center; justify-content:space-between;
    background:#0b1221; cursor:pointer; margin-bottom:.35rem; }
  #swap-chooser .opt.active { outline:2px solid #fbbf24; }
  #swap-chooser .tag { font-size:.7rem; padding:.1rem .4rem; border-radius:9999px; border:1px solid #475569; background:#111827; }

  @media (max-width:640px){.circle{width:92vw;height:92vw}.seat{width:30vw;height:34vw}.card{width:10vw;height:14vw}}
</style>
</head>
<body class="tavern text-slate-100">
<div class="max-w-7xl mx-auto p-4 md:p-6">
  <header class="mb-4 md:mb-6 flex items-center justify-between gap-3">
    <div>
      <h1 class="text-2xl md:text-3xl font-extrabold tracking-tight">The Dead Man’s Draw <span class="text-amber-400">– D&D Tavern</span></h1>
      <p class="text-slate-300 text-sm md:text-base">“Stjæl & Byt” • 1–4 spillere, NPC-bots, online/lokalt • Undgå <span class="text-rose-400 font-semibold">Death</span>.</p>
    </div>
    <div class="hidden sm:flex items-center gap-3">
      <div class="token" id="pot-badge">0</div><span class="text-xs text-slate-400">guld i potten</span>
    </div>
  </header>

  <section class="grid xl:grid-cols-4 gap-4 mb-5">
    <!-- Opsætning -->
    <div class="xl:col-span-3 rounded-2xl border border-slate-800 bg-slate-900/60 p-4">
      <h2 class="font-semibold mb-2">Spilopsætning</h2>

      <div class="flex flex-wrap gap-2 items-center mb-3">
        <span class="text-sm text-slate-300">Spillere:</span>
        <button class="tab px-3 py-1 rounded-lg bg-slate-800 border border-slate-700" data-p="1">1p</button>
        <button class="tab px-3 py-1 rounded-lg bg-slate-800 border border-slate-700" data-p="2">2p</button>
        <button class="tab px-3 py-1 rounded-lg bg-slate-800 border border-slate-700" data-p="3">3p</button>
        <button class="tab px-3 py-1 rounded-lg bg-slate-800 border border-slate-700" data-p="4">4p</button>
        <label class="ml-2 text-xs flex items-center gap-2"><input id="fill-npc" type="checkbox" class="accent-amber-500" checked> Fyld tomme sæder med NPC’er</label>
        <label class="ml-2 text-xs flex items-center gap-2"><input id="use-net" type="checkbox" class="accent-emerald-500" checked> Online (Supabase)</label>
      </div>

      <div id="names" class="grid sm:grid-cols-2 md:grid-cols-4 gap-2 mb-2"></div>

      <div class="grid md:grid-cols-3 gap-2">
        <div>
          <label class="text-sm">Dit navn</label>
          <input id="my-name" class="w-full px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" placeholder="DM/Spiller" />
        </div>
        <div>
          <label class="text-sm">Indsats pr. spiller</label>
          <div class="flex gap-2">
            <input id="stake" type="number" min="0" value="10" class="w-28 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" />
            <button id="set-stake" class="px-3 py-2 rounded-xl bg-amber-600 hover:bg-amber-500">Sæt</button>
          </div>
        </div>
        <div>
          <label class="text-sm">Pass-runder pr. runde</label>
          <div class="flex gap-2">
            <input id="pass-rounds" type="number" min="1" max="10" value="1" class="w-28 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" />
            <button id="set-pass" class="px-3 py-2 rounded-xl bg-sky-700 hover:bg-sky-600">Gem</button>
          </div>
          <p class="text-xs text-slate-400 mt-1">Afslør efter så mange <em>hele</em> omgange (alle har haft tur).</p>
        </div>
      </div>

      <div class="mt-3 flex flex-wrap gap-2">
        <button id="init" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500">Initialisér</button>
        <button id="make" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500">Opret rum</button>
        <input id="room" class="px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" placeholder="RUMKODE" />
        <button id="join" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500">Join</button>
        <span class="text-xs text-slate-400 self-center">Rum: <span id="ui-room" class="font-mono">—</span></span>
        <span class="text-xs text-slate-400 self-center">Fase: <span id="ui-phase" class="pill">Lobby</span></span>
        <span class="text-xs text-slate-400 self-center">Turfase: <span id="ui-turn" class="pill">—</span></span>
        <span class="text-xs text-slate-400 self-center">Realtime: <span id="ui-rt" class="pill">Ikke forbundet</span></span>
      </div>

      <div class="mt-3 flex flex-wrap gap-2 items-center">
        <button id="start-round" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500">Start runde</button>
        <button id="reveal" class="px-3 py-2 rounded-xl bg-rose-700 hover:bg-rose-600">Afslør & eliminer</button>
        <button id="force-final" class="px-3 py-2 rounded-xl bg-fuchsia-700 hover:bg-fuchsia-600">Tving finale (1v1)</button>

        <button id="confirm-swap" class="ml-auto px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50" disabled>Byt nu</button>
        <button id="show-hand" class="px-3 py-2 rounded-xl bg-slate-700">Se mine kort</button>
      </div>
    </div>

    <!-- Sidepanel -->
    <aside class="rounded-2xl border border-slate-800 bg-slate-900/70 p-4 rules">
      <div class="flex items-center justify-between">
        <h3 class="font-semibold">Regler – “Stjæl & Byt”</h3>
        <button id="toggle-rules" class="text-xs px-2 py-1 rounded-lg bg-slate-800 border border-slate-700">Vis</button>
      </div>
      <div id="rules-body" class="hidden mt-2 text-xs leading-5 space-y-2">
        <p><strong>Formål:</strong> Undgå <span class="text-rose-400 font-semibold">Death</span>. Sidste spiller uden Death vinder potten.</p>
        <p><strong>Opsætning:</strong> 8 kort – 1× Death, 7× Life. Alle får 2 kort. Indsats i potten.</p>
        <p><strong>Tur:</strong> Vælg en modstander → vælg deres venstre/højre <em>ukendte</em> kort → du modtager det → vælg ét af dine <em>oprindelige</em> kort at give tilbage (ikke det du lige tog). Begge ender på 2 kort.</p>
        <p><strong>Omgange:</strong> Når alle har haft tur = 1 omgang. Efter det valgte antal omgange afsløres, spilleren med Death er ude.</p>
        <p><strong>Finale (1v1):</strong> 8 nedadvendte kort i cirkel. Træk på skift; den der trækker Death taber.</p>
      </div>

      <div class="mt-4 flex items-center justify-between">
        <h3 class="font-semibold">Log</h3>
        <button id="toggle-log" class="text-xs px-2 py-1 rounded-lg bg-slate-800 border border-slate-700">Vis</button>
      </div>
      <div id="log-wrap" class="hidden">
        <div id="log" class="scrollbox mt-2 h-56 overflow-auto text-xs bg-slate-950/40 border border-slate-800 rounded-xl p-2"></div>
      </div>

      <h3 class="font-semibold mt-4">Spillere</h3>
      <ul id="players" class="mt-2 space-y-2 text-sm"></ul>
    </aside>
  </section>

  <!-- Bord -->
  <section class="rounded-3xl wood p-6">
    <div class="circle" id="table"></div>
    <div class="mt-3 flex flex-wrap items-center gap-2 sm:hidden">
      <div class="token" id="pot-badge-sm">0</div><span class="text-xs text-slate-300">guld i potten</span>
    </div>
  </section>

  <footer class="mt-8 text-xs text-slate-500">Fan-projekt til hjemmebrug. 🍻</footer>
</div>

<script type="module">
/* ====== Supabase ====== */
const SUPABASE_URL  = "https://oiylsrbztgpplztngkhr.supabase.co";
const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9peWxzcmJ6dGdwcGx6dG5na2hyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ3Mjg5NzUsImV4cCI6MjA3MDMwNDk3NX0.CtyNtAjAfH35Y1iTNB4SbQVczOiDFMybNgkftb3amUU";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import Peer from 'https://esm.sh/simple-peer@9.11.1';

/* ====== Helpers ====== */
const $ = s => document.querySelector(s);
const log = (m)=>{ const d=document.createElement('div'); d.textContent = `[${new Date().toLocaleTimeString()}] ${m}`; const el=$('#log'); if(el){ el.appendChild(d); el.scrollTop = el.scrollHeight; } };
const rnd = (n)=>Math.floor(Math.random()*n);
const hostId = ()=> Object.keys(S.presence).find(id=>S.presence[id]?.host) || S.seats[0] || null;

/* ====== State ====== */
const S = {
  useNet:true, sb:null, channel:null, room:null, isHost:false,
  me:{ id: crypto.randomUUID(), name:'' },
  presence:{}, peers:new Map(),

  phase:'lobby',
  seats:[],           // autoritativ sæderækkefølge fra host (array af ids)
  seatNames:{},       // NY: navn pr. seat-id fra host
  alive:new Set(),
  bots:{},

  startIdx:0, turnIdx:0,
  hands:{}, counts:{}, localHand:[],
  stake:10, pot:0, modePlayers:4,

  passTarget:1, passLapCount:0,

  // UI-turn
  turnStage:'idle', // 'chooseTarget' | 'chooseOppCard' | 'chooseGiveBack' | 'idle'
  pending:{ targetId:null, oppIdx:null, receivedIndex:null },
  selectedIdx:null,

  botTimer:null
};
const DEFAULT_NPCS = ["Barkeep Borin","Sable the Cutpurse","Priestess Kael","Old Man Rook","Garruk the Smith","Nina Nightjar","Sir Thorne","Mina Quickstep","Vex the Bard","Hilda Ember","Karn Ironjaw","Willow Whisper"];

/* ====== UI refs ====== */
const namesWrap=$('#names'), table=$('#table'), playersList=$('#players');
const potBadge=$('#pot-badge'), potBadgeSm=$('#pot-badge-sm');
const confirmBtn = $('#confirm-swap');

/* ====== Tabs/toggles ====== */
const tabs=[...document.querySelectorAll('.tab')];
tabs.forEach(b=> b.onclick=()=> setMode(parseInt(b.dataset.p,10)));
$('#fill-npc').onchange = renderNameInputs;
$('#use-net').onchange  = e => S.useNet = e.target.checked;
$('#my-name').oninput   = renderNameInputs;

$('#toggle-rules').onclick = ()=>{
  const body=$('#rules-body'); const btn=$('#toggle-rules');
  if(body.classList.contains('hidden')){ body.classList.remove('hidden'); btn.textContent='Skjul'; }
  else { body.classList.add('hidden'); btn.textContent='Vis'; }
};
const logWrapEl = $('#log-wrap'); const toggleLogBtn = $('#toggle-log');
toggleLogBtn.onclick = ()=>{
  if (logWrapEl.classList.contains('hidden')) { logWrapEl.classList.remove('hidden'); toggleLogBtn.textContent='Skjul'; }
  else { logWrapEl.classList.add('hidden'); toggleLogBtn.textContent='Vis'; }
};

function setMode(p){ S.modePlayers=p; tabs.forEach(b=> b.classList.toggle('bg-emerald-700', parseInt(b.dataset.p,10)===p)); renderNameInputs(); }
function renderNameInputs(){
  namesWrap.innerHTML=''; const p=S.modePlayers, fillNPC=$('#fill-npc').checked;
  for(let i=0;i<4;i++){
    const npc=i>=p && fillNPC;
    namesWrap.insertAdjacentHTML('beforeend',`
      <div>
        <label class="text-sm">${i<p?`Spiller ${i+1}`:`Sæde ${i+1}`}${npc?' (NPC)':''}</label>
        <input data-seat="${i}" class="w-full px-3 py-2 rounded-lg bg-slate-800 border border-slate-700 seat-name"
               placeholder="${npc? DEFAULT_NPCS[i%DEFAULT_NPCS.length] : 'Navn'}"
               value="${i===0?($('#my-name').value||''):''}">
      </div>`);
  }
}
setMode(4);

/* ====== Supabase init ====== */
let supabase;
$('#init').onclick=()=>{
  if(!S.useNet){ log('🔌 Offline/solo – springer Supabase over.'); return; }
  supabase=createClient(SUPABASE_URL,SUPABASE_ANON,{realtime:{params:{eventsPerSecond:5}}});
  S.sb=supabase; log('✅ Supabase klar.');
};

$('#make').onclick = async ()=>{ await ensureNetIfWanted(); setupNames(); const code=makeRoom(); $('#room').value=code; await join(code,true); };
$('#join').onclick = async ()=>{ await ensureNetIfWanted(); setupNames(); const code=($('#room').value||'').trim().toUpperCase(); if(!code) return alert('Rumkode?'); await join(code,false); };

$('#set-stake').onclick = ()=> isHostOnly(()=> publish({t:'stake', v: Math.max(0, parseInt($('#stake').value||'10',10))}));
$('#set-pass').onclick  = ()=> isHostOnly(()=> publish({t:'passTarget', v: Math.max(1, Math.min(10, parseInt($('#pass-rounds').value||'1',10)))}));

/* ====== Net helpers ====== */
async function ensureNetIfWanted(){ if(!S.useNet) return; if(!S.sb) $('#init').click(); if(!S.sb) throw new Error('Supabase ikke initialiseret'); }
function makeRoom(){ const chars='ABCDEFGHJKMNPQRSTUVWXYZ23456789'; let s=''; for(let i=0;i<5;i++) s+=chars[rnd(chars.length)]; return s; }
function isHostOnly(fn){ if(!S.isHost){ alert('Kun værten kan ændre dette.'); return; } fn(); }

/* ====== Join (presence + seatmap) ====== */
async function join(code, asHost){
  S.room=code; S.isHost=!!asHost; $('#ui-room').textContent=code;
  S.alive=new Set(); S.bots={}; S.presence={}; S.localHand=[]; S.selectedIdx=null; S.turnStage='idle'; S.pending={targetId:null,oppIdx:null,receivedIndex:null};
  S.hands={}; S.counts={}; S.seats=[]; S.seatNames={};

  const seatInputs=[...document.querySelectorAll('.seat-name')];
  const inputNames = seatInputs.map((el,i)=> (el.value||el.placeholder||`Sæde ${i+1}`));
  const p=S.modePlayers, fillNPC=$('#fill-npc').checked;
  const activeNames=[];
  for(let i=0;i<4;i++){ if(i<p) activeNames.push(inputNames[i]||`Spiller ${i+1}`); else if(fillNPC) activeNames.push(inputNames[i]||DEFAULT_NPCS[i%DEFAULT_NPCS.length]); }

  const myName=$('#my-name').value||'DM'; S.me.name=myName;

  if(S.useNet){
    if(!S.sb) $('#init').click();

    S.channel = S.sb.channel(`tavern-${code}`, { config:{ broadcast:{ self:true }, presence:{ key:S.me.id } } });

    S.channel.on('presence',{event:'sync'},()=>{
      const st=S.channel.presenceState(); const list=Object.values(st).flat().map(p=>p.meta);
      for(const p of list){ S.presence[p.id]={id:p.id,name:p.name,host:!!p.host, seatAck: S.presence[p.id]?.seatAck||false}; }
      renderAll();
      log('👥 Presence sync: ' + list.map(p=>p.name).join(', '));
      if(S.isHost){ assignMissingSeats(activeNames); }
    });

    S.channel.on('broadcast',{event:'public'},({payload})=> onPublic(payload));
    S.channel.on('broadcast',{event:'signal'},({payload})=> onSignal(payload));

    // subscribe (VENT og log alt)
    const { error: subErr } = await S.channel.subscribe((status) => {
      log(`🔄 Realtime status: ${status}`);
    });
    if (subErr) {
      console.error(subErr);
      log('❌ SUBSCRIBE FEJLEDE: ' + subErr.message);
      alert('Realtime subscribe fejlede. Tjek internet/HTTPS/CORS.');
      return;
    }

    const { error: trackErr } = await S.channel.track({ id:S.me.id, name:myName, host:S.isHost });
    if (trackErr) {
      console.error(trackErr);
      log('❌ TRACK FEJLEDE: ' + trackErr.message);
    } else {
      log('✅ TRACK OK – du er synlig for andre.');
    }
    const rt = $('#ui-rt'); if (rt) rt.textContent = 'Tilsluttet';

    // Ping til rummet så host ser dig i loggen
    publish({ t:'info', m:`📡 ${myName} siger hej!` });

    // Host: initial seatmap
    if(S.isHost){
      S.seats=[S.me.id];
      S.seatNames[S.me.id]=myName;
      for(let i=1;i<activeNames.length;i++){
        const npcId = crypto.randomUUID();
        S.seats.push(npcId);
        S.bots[npcId]={isBot:true,name:activeNames[i]};
        S.seatNames[npcId]=activeNames[i];
      }
      S.alive = new Set(S.seats);
      publish({t:'config', stake:S.stake, passTarget:S.passTarget});
      broadcastSeatmap();
      log(`Du er ${myName} (host). Del rumkode: ${S.room}`);
    } else {
      // Klient: bed om sæde
      publish({t:'seatRequest', id:S.me.id, name:myName});
    }
  } else {
    // Offline/solo
    log('🔌 Offline/solo–mode.');
    S.seats=[S.me.id]; S.seatNames[S.me.id]=myName;
    for(let i=1;i<activeNames.length;i++){ const npcId=crypto.randomUUID(); S.seats.push(npcId); S.bots[npcId]={isBot:true,name:activeNames[i]}; S.seatNames[npcId]=activeNames[i]; }
    S.alive = new Set(S.seats);
    S.presence[S.me.id]={id:S.me.id,name:myName,host:true,seatAck:true};
    renderAll();
  }

  recalcPot();
}

/* ====== Seatmap – host autoritet + ack-loop ====== */
function assignMissingSeats(activeNames){
  const presentIds = Object.keys(S.presence);
  const unknown = presentIds.filter(id => !S.seats.includes(id) && !S.bots[id]);
  if(!unknown.length) return;

  for(const uid of unknown){
    hostSeatPlayer(uid, S.presence[uid]?.name || 'spiller');
  }
  broadcastSeatmap();
}

function hostSeatPlayer(uid, name){
  S.presence[uid] = S.presence[uid] || { id: uid, name, host:false, seatAck:false };

  let idx = S.seats.findIndex((sid, i)=> i>0 && S.bots[sid]); // undgå host-pladsen (i=0)
  if (idx === -1) {
    if (S.seats.length < 4) {
      idx = S.seats.length;
      S.seats.push(uid);
    } else {
      log(`⚠️ Ingen ledig plads til ${name}.`);
      return;
    }
  } else {
    const botId = S.seats[idx];
    delete S.bots[botId];
    S.seats[idx] = uid;
  }

  S.seatNames[uid] = name;
  S.alive.add(uid);
  log(`🪑 Placerer ${name} på sæde ${idx+1}.`);

  publish({ t:'config', stake:S.stake, passTarget:S.passTarget });
  broadcastSeatmap();
}

function broadcastSeatmap(){
  // med navne!
  publish({
    t:'seatmap',
    seats:S.seats,
    seatNames:S.seatNames,
    bots: Object.fromEntries(Object.entries(S.bots).map(([id,b])=>[id,{name:b.name}]))
  });

  // direkte "du sidder på index X" til hver menneske-klient
  if(S.useNet){
    for(const id of S.seats){
      if(S.presence[id]){ // menneske
        const idx = S.seats.indexOf(id);
        S.channel.send({type:'broadcast', event:'signal', payload:{ from:S.me.id, to:id, data:{ type:'seatAssign', index: idx } }});
      }
    }
  }
  renderAll();

  // Ack-loop
  if (S.isHost) {
    let tries = 0;
    const ackTimer = setInterval(() => {
      tries++;
      const humans = S.seats.filter(id => S.presence[id]);
      const missing = humans.filter(id => !S.presence[id]?.seatAck);
      if (missing.length === 0 || tries > 10) { clearInterval(ackTimer); return; }
      log('↻ Venter på seat-ack fra: ' + missing.map(id => S.presence[id]?.name || id).join(', '));
      publish({
        t:'seatmap', seats:S.seats, seatNames:S.seatNames,
        bots: Object.fromEntries(Object.entries(S.bots).map(([id,b])=>[id,{name:b.name}]))
      });
      for(const id of missing){
        const idx = S.seats.indexOf(id);
        S.channel.send({type:'broadcast', event:'signal', payload:{ from:S.me.id, to:id, data:{ type:'seatAssign', index: idx } }});
      }
    }, 3000);
  }
}

/* ====== Broadcast routing ====== */
function publish(payload){ if(S.useNet) S.channel.send({type:'broadcast',event:'public',payload}); else onPublic(payload); }
function onPublic(msg){
  if(msg.t==='config'){ if(typeof msg.stake==='number') S.stake=msg.stake; if(typeof msg.passTarget==='number') S.passTarget=msg.passTarget; $('#stake').value=S.stake; $('#pass-rounds').value=S.passTarget; recalcPot(); }

  if(msg.t==='seatRequest' && S.isHost){ hostSeatPlayer(msg.id, msg.name||'spiller'); }

  if(msg.t==='seatmap'){
    S.seats = msg.seats.slice();
    S.seatNames = Object.assign({}, msg.seatNames||{});
    S.bots={}; for(const [id,b] of Object.entries(msg.bots||{})){ S.bots[id]={isBot:true,name:b.name}; }
    S.alive = new Set(S.seats); renderAll(); recalcPot();
  }

  if(msg.t==='stake'){ if(S.isHost){ publish({t:'config', stake:msg.v}); } S.stake=msg.v; recalcPot(); log(`Indsats: ${S.stake} guld`); }
  if(msg.t==='passTarget'){ if(S.isHost){ publish({t:'config', passTarget:msg.v}); } S.passTarget=Math.max(1,Math.min(10,msg.v|0)); $('#pass-rounds').value=S.passTarget; log(`Pass-runder pr. runde: ${S.passTarget}`); }

  if(msg.t==='startRound'){ startRoundApply(msg.order, msg.startIdx, msg.dealer); }
  if(msg.t==='enableTurn'){ if(msg.id===S.me.id) beginMyTurn(); else maybeBotTakeTurn(msg.id); }

  if(msg.t==='askOppCard'){ onAskOppCard(msg.thief, msg.target, msg.idx); }
  if(msg.t==='gotOppCard'){ onGotOppCard(msg.thief); }
  if(msg.t==='turnDone'){ applyTurnAdvance(); }

  if(msg.t==='reveal'){ doReveal(); }
  if(msg.t==='elim'){ eliminate(msg.id); }
  if(msg.t==='final'){ startFinal(msg.first); }
  if(msg.t==='finalPick'){ finalApplyPick(msg.id, msg.idx, msg.card); }
  if(msg.t==='end'){ endGame(msg.winner); }

  if(msg.t==='info'){ log(msg.m); }
  renderAll();
}

/* ====== P2P + Realtime DM fallback ====== */
function onSignal({from,to,data}){
  if(!S.useNet) return;

  // seatAssign → klient sender ACK direkte til host
  if (to===S.me.id && data?.type==='seatAssign') {
    const idx = data.index;
    const hid = hostId();
    if (hid && S.channel) {
      S.channel.send({ type:'broadcast', event:'signal',
        payload:{ from:S.me.id, to:hid, data:{ type:'seatAck', who:S.me.id, index:idx } }
      });
    }
    log(`🪑 Du er placeret på sæde ${idx+1}.`);
    return;
  }

  // seatAck (host modtager – uanset 'to'-match)
  if (data?.type==='seatAck') {
    if (S.isHost && S.presence[data.who]) {
      S.presence[data.who].seatAck = true;
      log(`✅ Seat-ack fra ${S.presence[data.who].name||data.who}.`);
    }
    return;
  }

  // DM-kort
  if (to===S.me.id && data?.type==='cardToThief') { log('📬 Modtog kort (DM fallback) → thief'); thiefReceiveCard(data.card); return; }
  if (to===S.me.id && data?.type==='cardToTarget'){ log('📬 Modtog kort (DM fallback) → target'); targetReceiveCard(data.card, data.target); return; }

  // WebRTC signaler (P2P)
  if(to && to!==S.me.id) return;
  let p=S.peers.get(from);
  const shouldInitiate = !p && (S.isHost || S.me.id < from);
  if(!p){
    p = new Peer({ initiator: shouldInitiate, trickle:false });
    p.on('signal',d=> S.channel.send({type:'broadcast',event:'signal',payload:{from:S.me.id,to:from,data:d}}));
    p.on('data',buf=>{
      try{ const m=JSON.parse(buf.toString());
        if(m.t==='cardToThief') thiefReceiveCard(m.card);
        if(m.t==='cardToTarget') targetReceiveCard(m.card, m.target);
      }catch(e){}
    });
    p.on('error',e=>console.warn(e)); p.on('close',()=>S.peers.delete(from));
    S.peers.set(from,p);
  }
  try{ p.signal(data); }catch(e){}
}
async function ensurePeer(otherId, initiator){
  if(S.peers.has(otherId)) return S.peers.get(otherId);
  const p=new Peer({initiator, trickle:false});
  p.on('signal',data=> S.channel.send({type:'broadcast',event:'signal',payload:{from:S.me.id,to:otherId,data}}));
  p.on('data',buf=>{ try{ const m=JSON.parse(buf.toString()); if(m.t==='cardToThief') thiefReceiveCard(m.card); if(m.t==='cardToTarget') targetReceiveCard(m.card, m.target); }catch(e){} });
  p.on('error',e=>console.warn(e)); p.on('close',()=>S.peers.delete(otherId));
  S.peers.set(otherId,p);
  return p;
}
async function sendCardToThief(thiefId, card){
  if(S.useNet){
    const p = await ensurePeer(thiefId, S.isHost || S.me.id<thiefId);
    if(p && p.connected){ try{ p.send(JSON.stringify({t:'cardToThief', card})); return; }catch{} }
    S.channel.send({ type:'broadcast', event:'signal', payload:{ from:S.me.id, to:thiefId, data:{ type:'cardToThief', card } }});
    return;
  }
  if(thiefId===S.me.id) thiefReceiveCard(card);
}
async function sendCardToTarget(targetId, card){
  if(S.useNet){
    const p = await ensurePeer(targetId, S.isHost || S.me.id<targetId);
    if(p && p.connected){ try{ p.send(JSON.stringify({t:'cardToTarget', card, target:targetId})); return; }catch{} }
    S.channel.send({ type:'broadcast', event:'signal', payload:{ from:S.me.id, to:targetId, data:{ type:'cardToTarget', card, target:targetId } }});
    return;
  }
  if(targetId===S.me.id) targetReceiveCard(card, targetId);
}

/* ====== Kontroller ====== */
$('#start-round').onclick=()=>{
  if(!S.isHost){ alert('Kun værten kan starte en runde.'); return; }
  if(S.alive.size===0) S.alive=new Set(S.seats);
  const alive = Array.from(S.alive);
  if(alive.length<2) return alert('Kræver mindst 2 spillere. Fyld op med NPC’er eller spil 1p.');
  if(alive.length===2){ publish({t:'final', first:alive[rnd(2)]}); return; }

  const order = S.seats.slice(); // sæderækkefølge
  const startIdx = 0;            // host starter
  publish({t:'startRound', order, startIdx, dealer:S.me.id});
};
$('#reveal').onclick = ()=> isHostOnly(()=> publish({t:'reveal'}));
$('#force-final').onclick=()=>{
  if(!S.isHost){ alert('Kun værten kan tvinge finale.'); return; }
  const alive=Array.from(S.alive);
  if(alive.length!==2) return alert('Finale kræver 2 spillere');
  publish({t:'final', first:alive[rnd(2)]});
};
$('#show-hand').onclick=()=>{
  const label = S.localHand.map((c)=> (c==='death'?'DEATH':'Life')).join(' , ');
  alert('Dine kort: ' + (label || '(ingen)'));
};
confirmBtn.onclick = confirmGiveBack;

/* ====== Render ====== */
function renderAll(){
  renderPlayers();
  renderTable();
  $('#ui-phase').textContent=({lobby:'Lobby',round:'Runde',reveal:'Afsløring',final:'Finale',end:'Slut'})[S.phase]||S.phase;
  $('#ui-turn').textContent=S.turnStage==='idle'?'—':(
    S.turnStage==='chooseTarget'?'Vælg modstander':
    S.turnStage==='chooseOppCard'?'Vælg modstanders kort':
    S.turnStage==='chooseGiveBack'?'Vælg dit kort (byttes)':'—'
  );
  potBadge.textContent=String(S.pot); potBadgeSm.textContent=String(S.pot);
  const rt=$('#ui-rt'); if(rt) rt.textContent = S.channel ? 'Tilsluttet' : 'Ikke forbundet';

  $('#start-round').disabled = !S.isHost;
  $('#set-stake').disabled  = !S.isHost;
  $('#set-pass').disabled   = !S.isHost;

  confirmBtn.disabled = !(S.turnStage==='chooseGiveBack' && S.selectedIdx!==null);
}
function nameOf(id){
  return S.presence[id]?.name || S.seatNames[id] || S.bots[id]?.name || 'NPC';
}
function renderPlayers(){
  playersList.innerHTML='';
  const ids=S.seats.length? S.seats : Object.keys(S.presence);
  ids.forEach(id=>{
    const li=document.createElement('li');
    const alive=S.alive.has(id);
    const name = nameOf(id);
    li.className='flex items-center justify-between px-3 py-2 rounded-lg bg-slate-950/50 border border-slate-800';
    li.innerHTML=`<span>${name}${S.presence[id]?.host?' <span class="text-amber-400 text-xs">(host)</span>':''}${S.bots[id]?' <span class="text-xs text-fuchsia-400">(NPC)</span>':''}</span>
                  <span class="text-xs ${alive?'text-emerald-400':'text-rose-400'}">${alive?'i spil':'ude'}</span>`;
    playersList.appendChild(li);
  });
}
function renderTable(){
  const ids = S.seats.length? S.seats : Object.keys(S.presence);
  table.innerHTML = '';
  const n = ids.length || 4; const r = 220;

  ids.forEach((id,i)=>{
    const angle=(i/n)*Math.PI*2 - Math.PI/2;
    const x=260+Math.cos(angle)*r, y=260+Math.sin(angle)*r;
    const seat=document.createElement('div'); seat.className='seat'; seat.style.left=x+'px'; seat.style.top=y+'px';

    const isTurnSeat = (S.phase==='round' && S.seats[S.turnIdx]===id);
    const nm = nameOf(id);
    seat.insertAdjacentHTML('afterbegin', `<div class="text-center mb-1 ${isTurnSeat?'text-amber-300':''}">${nm}</div>`);

    const row=document.createElement('div'); row.className='flex items-center justify-center gap-3';

    if(id===S.me.id){
      // mine kort
      S.localHand.forEach((card, idx)=>{
        const c=document.createElement('div'); c.className='card';
        if(card==='life') c.classList.add('life');
        if(card==='death') c.classList.add('death');

        if(S.phase==='round' && S.seats[S.turnIdx]===id && S.turnStage==='chooseGiveBack'){
          const isForbidden = (S.pending.receivedIndex===idx);
          c.classList.add('me-turn');
          if(S.selectedIdx===idx) c.classList.add('selected');
          c.title = isForbidden ? 'Du kan ikke give det kort tilbage, du lige tog' : 'Vælg dette kort at give tilbage';
          c.onclick = ()=>{
            if(isForbidden){ alert('Du skal give et af dine oprindelige kort tilbage – ikke det du lige tog.'); return; }
            S.selectedIdx = idx; renderAll();
          };
        }
        row.appendChild(c);
      });

      // overlay vælger
      const chooser = document.createElement('div');
      chooser.id='swap-chooser';
      if(S.phase==='round' && S.seats[S.turnIdx]===id && S.turnStage==='chooseGiveBack'){
        chooser.classList.add('show');
        chooser.innerHTML = `<div class="text-xs mb-2 text-slate-300">Vælg hvilket <b>oprindeligt</b> kort du vil give tilbage:</div>`;
        S.localHand.forEach((card, idx)=>{
          const isForbidden = (S.pending.receivedIndex===idx);
          if(isForbidden) return;
          const opt = document.createElement('div');
          opt.className='opt'+(S.selectedIdx===idx?' active':'');
          opt.innerHTML = `<span>${card==='death'?'DEATH':'Life'}</span><span class="tag">kort ${idx+1}</span>`;
          opt.onclick = ()=>{ S.selectedIdx=idx; renderAll(); };
          chooser.appendChild(opt);
        });
        const bar = document.createElement('div');
        bar.className='mt-2 flex gap-2';
        const btn = document.createElement('button');
        btn.className='px-3 py-1 rounded-lg bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50';
        btn.textContent = 'Byt nu';
        btn.disabled = (S.selectedIdx===null);
        btn.onclick = confirmGiveBack;
        bar.appendChild(btn);
        chooser.appendChild(bar);
      }
      seat.appendChild(chooser);

    } else {
      // MODSTANDERE: venstre/højre kort – ét klik vælger både mål og side
      for(let k=0;k<2;k++){
        const c=document.createElement('button');
        c.type='button';
        c.className='card opp-card-hit';
        c.title = 'Klik for at vælge';

        const myTurn = (S.phase==='round' && S.seats[S.turnIdx]===S.me.id);
        if(myTurn){
          if(S.turnStage==='chooseTarget'){
            c.classList.add('me-turn','targetable');
            c.onclick = ()=>{
              if(id===S.me.id) return;
              S.pending.targetId = id;
              S.turnStage = 'chooseOppCard';
              setTimeout(()=> chooseOppCardIndex(k), 0);
            };
          } else if(S.turnStage==='chooseOppCard' && S.pending.targetId===id){
            c.classList.add('me-turn','targetable');
            c.onclick = ()=> chooseOppCardIndex(k);
            c.onmouseenter = ()=> c.classList.add('selected');
            c.onmouseleave = ()=> c.classList.remove('selected');
          }
        }
        row.appendChild(c);
      }
    }

    seat.appendChild(row);
    table.appendChild(seat);
  });
}

/* ====== Pot ====== */
function recalcPot(){ const active= S.seats.filter(id=>S.alive.has(id)).length; S.pot=active*(S.stake||0); renderAll(); }

/* ====== Runde: start/deal (host-only) ====== */
function startRoundApply(order, startIdx, dealerId){
  S.seats=order.slice(); S.startIdx=startIdx%S.seats.length; S.turnIdx=S.startIdx;
  S.phase='round'; S.passLapCount=0; S.turnStage='idle'; S.selectedIdx=null; S.pending={targetId:null,oppIdx:null,receivedIndex:null};
  clearBotTimer();
  log('🃏 Ny runde – stjæl & byt.');
  S.localHand=[]; S.hands={}; S.counts={}; S.seats.forEach(id=> S.counts[id]=0);
  S.alive = new Set(S.seats);

  if(S.me.id===dealerId){
    publish({t:'info', m:'🂠 Host deler kort...'});
    log('🂠 Deler kort (host). P2P eller DM-fallback bruges pr. spiller.');
    const total=S.seats.length*2;
    const deck=Array(total).fill('life'); deck[rnd(total)]='death';

    for(let i=0;i<S.seats.length;i++){
      const pid=S.seats[i];
      for(let c=0;c<2;c++){
        const card=deck.splice(rnd(deck.length),1)[0];
        if(pid===S.me.id){ receiveCard(card); }
        else if(S.bots[pid]){ botReceiveCard(pid,card); }
        else { sendCardToThief(pid, card); }
      }
    }
  }
  publish({t:'enableTurn', id:S.seats[S.turnIdx]});
  recalcPot(); renderAll();
}

/* ====== Card IO ====== */
function receiveCard(card){ S.localHand.push(card); S.hands[S.me.id]=S.localHand; S.counts[S.me.id]=(S.counts[S.me.id]||0)+1; renderAll(); }
function botReceiveCard(id, card){ S.hands[id]=(S.hands[id]||[]); S.hands[id].push(card); S.counts[id]=(S.counts[id]||0)+1; }
function thiefReceiveCard(card){
  const newIdx = S.localHand.length;
  S.localHand.push(card);
  S.pending.receivedIndex = newIdx;
  S.turnStage='chooseGiveBack';
  log(`Du modtog modstanderens kort. Vælg nu ét af dine oprindelige kort at give tilbage.`);
  renderAll();
}
function targetReceiveCard(card, targetId){
  if(targetId!==S.me.id) return;
  S.localHand.push(card);
  renderAll();
}

/* ====== Turn flow ====== */
function beginMyTurn(){
  if(S.phase!=='round') return;
  clearBotTimer();
  S.turnStage='chooseTarget'; S.pending={targetId:null,oppIdx:null,receivedIndex:null}; S.selectedIdx=null;
  log('✨ Din tur: vælg en modstander.');
  renderAll();
}
function chooseOppCardIndex(idx){
  if(!(S.turnStage==='chooseOppCard' && S.pending.targetId)) return;
  S.pending.oppIdx = idx;
  publish({t:'askOppCard', thief:S.me.id, target:S.pending.targetId, idx});
  log(`Du vælger ${nameOf(S.pending.targetId)}s ${idx===0?'venstre':'højre'} kort...`);
}
function confirmGiveBack(){
  if(!(S.turnStage==='chooseGiveBack' && S.selectedIdx!==null)) return;
  if(S.selectedIdx===S.pending.receivedIndex){ alert('Du må ikke give det kort tilbage, du lige tog.'); return; }
  const give = S.localHand[S.selectedIdx];
  S.localHand.splice(S.selectedIdx,1);
  if(S.pending.receivedIndex > S.selectedIdx) S.pending.receivedIndex--;
  sendCardToTarget(S.pending.targetId, give);
  log(`Du gav et kort tilbage til ${nameOf(S.pending.targetId)}.`);
  S.turnStage='idle'; S.selectedIdx=null; S.pending={targetId:null,oppIdx:null,receivedIndex:null};
  publish({t:'turnDone'});
  renderAll();
}

/* ====== Events ====== */
function onAskOppCard(thiefId, targetId, idx){
  if(S.bots[targetId]){
    const h=S.hands[targetId]||[];
    const card=h.splice(idx,1)[0] ?? (Math.random()<0.125?'death':'life');
    sendCardToThief(thiefId, card);
    publish({t:'gotOppCard', thief:thiefId});
    return;
  }
  if(targetId!==S.me.id) return;
  const h=S.localHand;
  if(!h.length) return;
  const card = h.splice(Math.max(0,Math.min(idx,h.length-1)),1)[0];
  sendCardToThief(thiefId, card);
  log(`🔻 ${nameOf(thiefId)} tog ét af dine kort.`);
  renderAll();
  publish({t:'gotOppCard', thief:thiefId});
}
function onGotOppCard(thiefId){ /* UI opdateres via p2p/DM (thiefReceiveCard) */ }

/* ====== Next turn & laps ====== */
function applyTurnAdvance(){
  S.turnIdx=(S.turnIdx+1)%S.seats.length;

  const lapEnded = (S.turnIdx===S.startIdx);
  if(lapEnded){
    S.passLapCount++;
    log(`🔁 Omgang ${S.passLapCount}/${S.passTarget} fuldført.`);
    if(S.passLapCount>=S.passTarget){
      S.phase='reveal'; renderAll(); log('🔔 Omgange nået – klar til afsløring.');
      clearBotTimer();
      return;
    }
  }
  publish({t:'enableTurn', id:S.seats[S.turnIdx]});
  renderAll();
  maybeBotTakeTurn(S.seats[S.turnIdx]);
}

/* ====== Reveal / Elimination (host only) ====== */
function doReveal(){
  if(!S.isHost || S.phase!=='reveal') return;
  for(const id of S.seats){
    const hand = (id===S.me.id)? S.localHand : (S.hands[id]||[]);
    if(hand.includes('death')) publish({t:'elim', id});
  }
}
function eliminate(id){
  if(!S.alive.has(id)) return;
  S.alive.delete(id);
  log(`☠️ ${nameOf(id)} er ude (Death).`);
  const alive=Array.from(S.alive);
  if(alive.length===1) publish({t:'end', winner:alive[0]});
  else if(alive.length===2) publish({t:'final', first:alive[rnd(2)]});
  else { S.phase='lobby'; log('Værten kan starte næste runde.'); }
  recalcPot(); renderAll();
}

/* ====== Finale ====== */
let F={deck:[], face:[], turn:null};
function startFinal(first){
  S.phase='final'; renderAll(); clearBotTimer(); log('🏁 Finale! 8 kort i cirkel.');
  F.deck=Array(8).fill('life'); F.deck[rnd(8)]='death'; F.face=Array(8).fill(false); F.turn=first;
  if(F.turn===S.me.id) finalPickPrompt(); else if(S.bots[F.turn]) botFinalPick(F.turn);
}
function finalPickPrompt(){ const s=prompt('Finale: vælg felt 1–8'); const idx=Math.max(1,Math.min(8,parseInt(s||'1',10)))-1; const card=F.deck[idx]; publish({t:'finalPick', id:S.me.id, idx, card}); }
function finalApplyPick(id, idx, card){
  if(F.face[idx]) return; F.face[idx]=true;
  log(`🎲 ${nameOf(id)} trak ${card==='death'?'DEATH':'Life'}.`);
  if(card==='death'){ const loser=id; const alive=Array.from(S.alive); const winner=alive.find(x=>x!==loser)||S.me.id; publish({t:'end',winner}); return; }
  const alive=Array.from(S.alive); const other=alive.find(x=>x!==id);
  F.turn=other; if(other===S.me.id) finalPickPrompt(); else if(S.bots[other]) botFinalPick(other);
}
function endGame(winner){ S.phase='end'; renderAll(); clearBotTimer(); const name=nameOf(winner); log(`🏆 ${name} vinder og tager ${S.pot} guld!`); alert(`${name} vinder ${S.pot} guld!`); }

/* ====== Bots ====== */
function clearBotTimer(){ if(S.botTimer){ clearTimeout(S.botTimer); S.botTimer=null; } }
function maybeBotTakeTurn(id){
  clearBotTimer();
  if(S.phase!=='round' || !S.bots[id]) return;
  S.botTimer = setTimeout(()=>{
    if(S.phase!=='round' || S.seats[S.turnIdx]!==id) return;
    const lives=Array.from(S.alive).filter(x=>x!==id);
    const target = lives[rnd(lives.length)];
    const idx = rnd(2);
    const thand = S.hands[target]||[];
    const taken = thand.splice(idx,1)[0] || (Math.random()<0.125?'death':'life');
    const my = S.hands[id]||[];
    let giveIdx = my.findIndex(c=>c==='death'); if(giveIdx<0) giveIdx = 0;
    const give = my.splice(giveIdx,1)[0] || 'life';
    my.push(taken); S.hands[id]=my;
    const tgt = S.hands[target]||[]; tgt.push(give); S.hands[target]=tgt;
    log(`🤖 ${nameOf(id)} byttede med ${nameOf(target)}.`);
    publish({t:'turnDone'});
  }, 650+rnd(900));
}

/* ====== Misc ====== */
function setupNames(){ S.me.name=$('#my-name').value||'DM'; }

// Auto-init net (hjælper hvis man glemmer at trykke)
window.addEventListener('load', () => { try { $('#init').click(); } catch {} });
</script>
</body>
</html>
