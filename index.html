<!doctype html>
<html lang="da">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Dead Man‚Äôs Draw ‚Äì D&D Tavern (Steal & Swap)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  .tavern{background:
    radial-gradient(1200px 600px at 50% 20%,rgba(255,220,160,.08),transparent),
    radial-gradient(600px 300px at 10% 10%,rgba(255,255,255,.05),transparent),
    #0b0f17;min-height:100vh}
  .wood{background:
    radial-gradient(closest-side,rgba(0,0,0,.2),rgba(0,0,0,.5)),
    repeating-conic-gradient(from 0deg,#5d3a1a 0 10deg,#6f4621 10deg 20deg);
    border:8px solid #3d2a13;box-shadow:0 0 40px rgba(0,0,0,.6) inset,0 10px 30px rgba(0,0,0,.6)}
  .circle{position:relative;width:520px;height:520px;border-radius:50%;margin:0 auto}
  .seat{position:absolute;width:140px;height:140px;transform:translate(-50%,-50%)}
  .card{width:48px;height:70px;border-radius:8px;border:2px solid rgba(0,0,0,.6);
    box-shadow:0 2px 8px rgba(0,0,0,.5);background:linear-gradient(135deg,#222,#333);
    transition:transform .12s ease, box-shadow .12s ease, outline .12s ease; cursor:default}
  .card.me-turn{cursor:pointer}
  .life{background:linear-gradient(135deg,#164e63,#0e7490)!important}
  .death{background:linear-gradient(135deg,#3f1d1d,#7f1d1d)!important}
  .selected{outline:3px solid #fbbf24; box-shadow:0 0 18px rgba(251,191,36,.55)}
  .targetable{outline:2px dashed #60a5fa}
  .token{width:28px;height:28px;border-radius:50%;background:radial-gradient(circle at 30% 30%,#ffe38a,#b88700);
    border:2px solid #4a3406;box-shadow:0 1px 6px rgba(0,0,0,.6);display:inline-flex;align-items:center;justify-content:center;
    font-weight:700;font-size:12px;color:#3a2a02}
  .scrollbox{scrollbar-color:#334155 transparent}
  .rules a{color:#93c5fd;text-decoration:underline}
  .pill{display:inline-block;padding:.2rem .5rem;border-radius:9999px;border:1px solid #334155;background:#0f172a;color:#e2e8f0;font-size:.75rem}
  @media (max-width:640px){.circle{width:92vw;height:92vw}.seat{width:30vw;height:30vw}.card{width:10vw;height:14vw}}
</style>
</head>
<body class="tavern text-slate-100">
<div class="max-w-7xl mx-auto p-4 md:p-6">
  <header class="mb-4 md:mb-6 flex items-center justify-between gap-3">
    <div>
      <h1 class="text-2xl md:text-3xl font-extrabold tracking-tight">The Dead Man‚Äôs Draw <span class="text-amber-400">‚Äì D&D Tavern</span></h1>
      <p class="text-slate-300 text-sm md:text-base">‚ÄúStj√¶l & Byt‚Äù ‚Ä¢ 1‚Äì4 spillere, NPC-bots, online/lokalt ‚Ä¢ Undg√• <span class="text-rose-400 font-semibold">Death</span>.</p>
    </div>
    <div class="hidden sm:flex items-center gap-3">
      <div class="token" id="pot-badge">0</div><span class="text-xs text-slate-400">guld i potten</span>
    </div>
  </header>

  <section class="grid xl:grid-cols-4 gap-4 mb-5">
    <!-- Ops√¶tning -->
    <div class="xl:col-span-3 rounded-2xl border border-slate-800 bg-slate-900/60 p-4">
      <h2 class="font-semibold mb-2">Spilops√¶tning</h2>

      <div class="flex flex-wrap gap-2 items-center mb-3">
        <span class="text-sm text-slate-300">Spillere:</span>
        <button class="tab px-3 py-1 rounded-lg bg-slate-800 border border-slate-700" data-p="1">1p</button>
        <button class="tab px-3 py-1 rounded-lg bg-slate-800 border border-slate-700" data-p="2">2p</button>
        <button class="tab px-3 py-1 rounded-lg bg-slate-800 border border-slate-700" data-p="3">3p</button>
        <button class="tab px-3 py-1 rounded-lg bg-slate-800 border border-slate-700" data-p="4">4p</button>
        <label class="ml-2 text-xs flex items-center gap-2"><input id="fill-npc" type="checkbox" class="accent-amber-500"> Fyld tomme s√¶der med NPC‚Äôer</label>
        <label class="ml-2 text-xs flex items-center gap-2"><input id="use-net" type="checkbox" class="accent-emerald-500" checked> Online (Supabase)</label>
      </div>

      <div id="names" class="grid sm:grid-cols-2 md:grid-cols-4 gap-2 mb-2"></div>

      <div class="grid md:grid-cols-3 gap-2">
        <div>
          <label class="text-sm">Dit navn</label>
          <input id="my-name" class="w-full px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" placeholder="DM/Spiller" />
        </div>
        <div>
          <label class="text-sm">Indsats pr. spiller</label>
          <div class="flex gap-2">
            <input id="stake" type="number" min="0" value="10" class="w-28 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" />
            <button id="set-stake" class="px-3 py-2 rounded-xl bg-amber-600 hover:bg-amber-500">S√¶t</button>
          </div>
        </div>
        <div>
          <label class="text-sm">Pass-runder pr. runde</label>
          <div class="flex gap-2">
            <input id="pass-rounds" type="number" min="1" max="10" value="1" class="w-28 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" />
            <button id="set-pass" class="px-3 py-2 rounded-xl bg-sky-700 hover:bg-sky-600">Gem</button>
          </div>
          <p class="text-xs text-slate-400 mt-1">Afsl√∏r efter s√• mange <em>hele</em> omgange (alle har haft tur).</p>
        </div>
      </div>

      <div class="mt-3 flex flex-wrap gap-2">
        <button id="init" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500">Initialis√©r</button>
        <button id="make" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500">Opret rum</button>
        <input id="room" class="px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" placeholder="RUMKODE" />
        <button id="join" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500">Join</button>
        <span class="text-xs text-slate-400 self-center">Rum: <span id="ui-room" class="font-mono">‚Äî</span></span>
        <span class="text-xs text-slate-400 self-center">Fase: <span id="ui-phase" class="pill">Lobby</span></span>
        <span class="text-xs text-slate-400 self-center">Turfase: <span id="ui-turn" class="pill">‚Äî</span></span>
      </div>

      <div class="mt-3 flex flex-wrap gap-2 items-center">
        <button id="start-round" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500">Start runde</button>
        <button id="reveal" class="px-3 py-2 rounded-xl bg-rose-700 hover:bg-rose-600">Afsl√∏r & eliminer</button>
        <button id="force-final" class="px-3 py-2 rounded-xl bg-fuchsia-700 hover:bg-fuchsia-600">Tving finale (1v1)</button>

        <button id="confirm-swap" class="ml-auto px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50" disabled>Byt: giv valgt kort tilbage</button>
        <button id="show-hand" class="px-3 py-2 rounded-xl bg-slate-700">Se mine kort</button>
      </div>
    </div>

    <!-- Sidepanel: Regler + Log (kollapset fra start) + Spillere -->
    <aside class="rounded-2xl border border-slate-800 bg-slate-900/70 p-4 rules">
      <div class="flex items-center justify-between">
        <h3 class="font-semibold">Regler ‚Äì ‚ÄúStj√¶l & Byt‚Äù</h3>
        <button id="toggle-rules" class="text-xs px-2 py-1 rounded-lg bg-slate-800 border border-slate-700">Vis</button>
      </div>
      <div id="rules-body" class="hidden mt-2 text-xs leading-5 space-y-2">
        <p><strong>Form√•l:</strong> Undg√• <span class="text-rose-400 font-semibold">Death</span>. Sidste spiller uden Death vinder potten.</p>
        <p><strong>Ops√¶tning:</strong> 8 kort ‚Äì 1√ó Death, 7√ó Life. Alle f√•r 2 kort. Indsats i potten.</p>
        <p><strong>Tur:</strong> V√¶lg en modstander ‚Üí v√¶lg deres venstre/h√∏jre <em>ukendte</em> kort ‚Üí du modtager det ‚Üí v√¶lg √©t af dine <em>oprindelige</em> kort at give tilbage (ikke det du lige tog). Begge ender p√• 2 kort.</p>
        <p><strong>Omgange:</strong> N√•r alle har haft tur = 1 omgang. Efter det valgte antal omgange afsl√∏res, spilleren med Death er ude.</p>
        <p><strong>Finale (1v1):</strong> 8 nedadvendte kort i cirkel. Tr√¶k p√• skift; den der tr√¶kker Death taber.</p>
      </div>

      <div class="mt-4 flex items-center justify-between">
        <h3 class="font-semibold">Log</h3>
        <button id="toggle-log" class="text-xs px-2 py-1 rounded-lg bg-slate-800 border border-slate-700">Vis</button>
      </div>
      <div id="log-wrap" class="hidden">
        <div id="log" class="scrollbox mt-2 h-56 overflow-auto text-xs bg-slate-950/40 border border-slate-800 rounded-xl p-2"></div>
      </div>

      <h3 class="font-semibold mt-4">Spillere</h3>
      <ul id="players" class="mt-2 space-y-2 text-sm"></ul>
    </aside>
  </section>

  <!-- Bord -->
  <section class="rounded-3xl wood p-6">
    <div class="circle" id="table"></div>
    <div class="mt-3 flex flex-wrap items-center gap-2 sm:hidden">
      <div class="token" id="pot-badge-sm">0</div><span class="text-xs text-slate-300">guld i potten</span>
    </div>
  </section>

  <footer class="mt-8 text-xs text-slate-500">Fan-projekt til hjemmebrug. üçª</footer>
</div>

<script type="module">
/* ====== KONFIG: Din Supabase ====== */
const SUPABASE_URL  = "https://oiylsrbztgpplztngkhr.supabase.co";
const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9peWxzcmJ6dGdwcGx6dG5na2hyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ3Mjg5NzUsImV4cCI6MjA3MDMwNDk3NX0.CtyNtAjAfH35Y1iTNB4SbQVczOiDFMybNgkftb3amUU";

/* ====== Deps ====== */
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import Peer from 'https://esm.sh/simple-peer@9.11.1';

/* ====== Helpers ====== */
const $ = s => document.querySelector(s);
const log = (m)=>{ const d=document.createElement('div'); d.textContent = `[${new Date().toLocaleTimeString()}] ${m}`; const el=$('#log'); if(el){ el.appendChild(d); el.scrollTop = el.scrollHeight; } };
const rnd = (n)=>Math.floor(Math.random()*n);

/* ====== State ====== */
const S = {
  useNet:true, sb:null, channel:null, room:null, isHost:false,
  me:{ id: crypto.randomUUID(), name:'' },
  presence:{}, peers:new Map(),
  phase:'lobby',
  seats:[], alive:new Set(), startIdx:0, turnIdx:0,
  hands:{}, counts:{}, localHand:[],
  stake:10, pot:0, modePlayers:4, bots:{},

  passTarget:1, passLapCount:0,

  // Steal & swap UI-state
  turnStage:'idle', // 'chooseTarget' | 'chooseOppCard' | 'chooseGiveBack' | 'idle'
  pending:{ targetId:null, oppIdx:null, receivedIndex:null },

  selectedIdx:null // used in chooseGiveBack to pick which of *your original* cards to give back
};
const DEFAULT_NPCS = ["Barkeep Borin","Sable the Cutpurse","Priestess Kael","Old Man Rook","Garruk the Smith","Nina Nightjar","Sir Thorne","Mina Quickstep","Vex the Bard","Hilda Ember","Karn Ironjaw","Willow Whisper"];

/* ====== UI wiring ====== */
const namesWrap=$('#names'), table=$('#table'), playersList=$('#players');
const potBadge=$('#pot-badge'), potBadgeSm=$('#pot-badge-sm');

const tabs=[...document.querySelectorAll('.tab')];
tabs.forEach(b=> b.onclick=()=> setMode(parseInt(b.dataset.p,10)));
$('#fill-npc').onchange = renderNameInputs;
$('#use-net').onchange  = e => S.useNet = e.target.checked;
$('#my-name').oninput   = renderNameInputs;

// Collapsers
$('#toggle-rules').onclick = ()=>{
  const body=$('#rules-body'); const btn=$('#toggle-rules');
  if(body.classList.contains('hidden')){ body.classList.remove('hidden'); btn.textContent='Skjul'; }
  else { body.classList.add('hidden'); btn.textContent='Vis'; }
};
const logWrapEl = $('#log-wrap'); const toggleLogBtn = $('#toggle-log');
toggleLogBtn.onclick = ()=>{
  if (logWrapEl.classList.contains('hidden')) { logWrapEl.classList.remove('hidden'); toggleLogBtn.textContent='Skjul'; }
  else { logWrapEl.classList.add('hidden'); toggleLogBtn.textContent='Vis'; }
};

function setMode(p){ S.modePlayers=p; tabs.forEach(b=> b.classList.toggle('bg-emerald-700', parseInt(b.dataset.p,10)===p)); renderNameInputs(); }
function renderNameInputs(){
  namesWrap.innerHTML=''; const p=S.modePlayers, fillNPC=$('#fill-npc').checked;
  for(let i=0;i<4;i++){
    const npc=i>=p && fillNPC;
    namesWrap.insertAdjacentHTML('beforeend',`
      <div>
        <label class="text-sm">${i<p?`Spiller ${i+1}`:`S√¶de ${i+1}`}${npc?' (NPC)':''}</label>
        <input data-seat="${i}" class="w-full px-3 py-2 rounded-lg bg-slate-800 border border-slate-700 seat-name"
               placeholder="${npc? DEFAULT_NPCS[i%DEFAULT_NPCS.length] : 'Navn'}"
               value="${i===0?($('#my-name').value||''):''}">
      </div>`);
  }
}
setMode(4);

/* ====== Supabase init ====== */
let supabase;
$('#init').onclick=()=>{
  if(!S.useNet){ log('üîå Offline/solo ‚Äì springer Supabase over.'); return; }
  supabase=createClient(SUPABASE_URL,SUPABASE_ANON,{realtime:{params:{eventsPerSecond:5}}});
  S.sb=supabase; log('‚úÖ Supabase klar.');
};

$('#make').onclick = async ()=>{ await ensureNetIfWanted(); setupNames(); const code=makeRoom(); $('#room').value=code; await join(code,true); };
$('#join').onclick = async ()=>{ await ensureNetIfWanted(); setupNames(); const code=($('#room').value||'').trim().toUpperCase(); if(!code) return alert('Rumkode?'); await join(code,false); };

$('#set-stake').onclick = ()=> publish({t:'stake', v: Math.max(0, parseInt($('#stake').value||'10',10))});
$('#set-pass').onclick  = ()=> publish({t:'passTarget', v: Math.max(1, Math.min(10, parseInt($('#pass-rounds').value||'1',10)))});

/* ====== Net helpers ====== */
async function ensureNetIfWanted(){ if(!S.useNet) return; if(!S.sb) $('#init').click(); if(!S.sb) throw new Error('Supabase ikke initialiseret'); }
function makeRoom(){ const chars='ABCDEFGHJKMNPQRSTUVWXYZ23456789'; let s=''; for(let i=0;i<5;i++) s+=chars[rnd(chars.length)]; return s; }

/* ====== Join (presence + bots) ====== */
async function join(code, asHost){
  S.room=code; S.isHost=!!asHost; $('#ui-room').textContent=code;
  S.alive=new Set(); S.bots={}; S.presence={}; S.localHand=[]; S.selectedIdx=null; S.turnStage='idle'; S.pending={targetId:null,oppIdx:null,receivedIndex:null};

  const seatInputs=[...document.querySelectorAll('.seat-name')];
  const inputNames = seatInputs.map((el,i)=> (el.value||el.placeholder||`S√¶de ${i+1}`));
  const p=S.modePlayers, fillNPC=$('#fill-npc').checked;
  const activeNames=[];
  for(let i=0;i<4;i++){ if(i<p) activeNames.push(inputNames[i]||`Spiller ${i+1}`); else if(fillNPC) activeNames.push(inputNames[i]||DEFAULT_NPCS[i%DEFAULT_NPCS.length]); }

  S.seats = activeNames.map(()=> crypto.randomUUID());
  if(S.seats.length===0) S.seats=[crypto.randomUUID()];
  S.seats[0]=S.me.id;

  const myName=$('#my-name').value||'DM'; S.me.name=myName;
  S.presence[S.me.id]={id:S.me.id,name:myName,host:S.isHost}; S.alive.add(S.me.id);
  for(let i=1;i<S.seats.length;i++){
    const id=S.seats[i]; const nm=activeNames[i]||DEFAULT_NPCS[i%DEFAULT_NPCS.length];
    S.presence[id]={id,name:nm,host:false}; S.alive.add(id);
    if(i>=p){ S.bots[id]={isBot:true,name:nm,style:'normal'}; }
  }

  renderAll(); recalcPot();

  if(S.useNet){
    if(!S.sb) $('#init').click();
    S.channel=S.sb.channel(`tavern-${code}`,{config:{broadcast:{self:true},presence:{key:S.me.id}}});
    S.channel.on('presence',{event:'sync'},()=>{
      const st=S.channel.presenceState(); const list=Object.values(st).flat().map(p=>p.meta);
      for(const p of list){ S.presence[p.id]={id:p.id,name:p.name,host:!!p.host}; }
      renderAll(); recalcPot();
    });
    S.channel.on('broadcast',{event:'public'},({payload})=> onPublic(payload));
    S.channel.on('broadcast',{event:'signal'},({payload})=> onSignal(payload));
    await S.channel.subscribe(async status=>{
      if(status!=='SUBSCRIBED') return;
      await S.channel.track({id:S.me.id,name:myName,host:S.isHost});
      log(`Du er ${myName}${S.isHost?' (host)':''}. Del rumkode: ${S.room}`);
      if(S.isHost){ publish({t:'info',m:`S√¶der: ${activeNames.join(', ')}`}); publish({t:'passTarget',v:S.passTarget}); publish({t:'stake',v:S.stake}); }
    });
  } else { log('üîå Offline/solo‚Äìmode.'); }
}

/* ====== Broadcast routing ====== */
function publish(payload){ if(S.useNet) S.channel.send({type:'broadcast',event:'public',payload}); else onPublic(payload); }
function onPublic(msg){
  if(msg.t==='stake'){ S.stake=msg.v; recalcPot(); log(`Indsats: ${S.stake} guld`); }
  if(msg.t==='passTarget'){ S.passTarget=Math.max(1,Math.min(10,msg.v|0)); $('#pass-rounds').value=S.passTarget; log(`Pass-runder pr. runde: ${S.passTarget}`); }
  if(msg.t==='startRound'){ startRoundApply(msg.seed, msg.order, msg.startIdx); }
  if(msg.t==='enableTurn'){ if(msg.id===S.me.id) beginMyTurn(); else maybeBotTakeTurn(msg.id); }
  if(msg.t==='askOppCard'){ onAskOppCard(msg.thief, msg.target, msg.idx); }
  if(msg.t==='gotOppCard'){ onGotOppCard(msg.thief); }
  if(msg.t==='turnDone'){ applyTurnAdvance(); }
  if(msg.t==='reveal'){ doReveal(); }
  if(msg.t==='elim'){ eliminate(msg.id); }
  if(msg.t==='final'){ startFinal(msg.seed, msg.first); }
  if(msg.t==='finalPick'){ finalApplyPick(msg.id, msg.idx, msg.card); }
  if(msg.t==='end'){ endGame(msg.winner); }
  if(msg.t==='info'){ log(msg.m); }
  renderAll();
}

/* ====== P2P for hemmelige kort ====== */
async function ensurePeer(otherId, initiator){
  if(S.peers.has(otherId)) return S.peers.get(otherId);
  const p=new Peer({initiator, trickle:false});
  p.on('signal',data=> S.channel.send({type:'broadcast',event:'signal',payload:{from:S.me.id,to:otherId,data}}));
  p.on('data',buf=>{ try{ const m=JSON.parse(buf.toString()); if(m.t==='cardToThief') thiefReceiveCard(m.card); if(m.t==='cardToTarget') targetReceiveCard(m.card, m.target); }catch(e){} });
  p.on('error',e=>console.warn(e)); p.on('close',()=>S.peers.delete(otherId));
  S.peers.set(otherId,p);
  if(!initiator) S.channel.send({type:'broadcast',event:'signal',payload:{from:S.me.id,to:null,data:{type:'hello'}}});
  return p;
}
function onSignal({from,to,data}){
  if(!S.useNet) return;
  if(data?.type==='hello' && S.isHost){ ensurePeer(from,true); return; }
  if(to && to!==S.me.id) return;
  let p=S.peers.get(from);
  if(!p){
    p=new Peer({initiator:false,trickle:false});
    p.on('signal',d=> S.channel.send({type:'broadcast',event:'signal',payload:{from:S.me.id,to:from,data:d}}));
    p.on('data',buf=>{ try{ const m=JSON.parse(buf.toString()); if(m.t==='cardToThief') thiefReceiveCard(m.card); if(m.t==='cardToTarget') targetReceiveCard(m.card, m.target); }catch(e){} });
    p.on('error',e=>console.warn(e)); p.on('close',()=>S.peers.delete(from));
    S.peers.set(from,p);
  }
  try{ p.signal(data); }catch(e){}
}
async function sendCardToThief(fromId, thiefId, card){
  if(!S.useNet){ if(thiefId===S.me.id) thiefReceiveCard(card); return; }
  const p=await ensurePeer(thiefId, S.isHost); p.send(JSON.stringify({t:'cardToThief', card}));
}
async function sendCardToTarget(thiefId, targetId, card){
  if(!S.useNet){ if(targetId===S.me.id) targetReceiveCard(card, targetId); return; }
  const p=await ensurePeer(targetId, S.isHost); p.send(JSON.stringify({t:'cardToTarget', card, target:targetId}));
}

/* ====== Kontroller ====== */
$('#start-round').onclick=()=>{
  if(S.alive.size===0) S.alive=new Set(Object.keys(S.presence));
  const alive=Array.from(S.alive);
  if(alive.length<2) return alert('Kr√¶ver mindst 2 spillere. Sl√• NPC-fyld til eller brug 1p.');
  if(alive.length===2) return publish({t:'final',seed:crypto.randomUUID(),first:alive[rnd(2)]});
  const seed=crypto.randomUUID(); const order=alive.slice(); const startIdx=rnd(order.length);
  publish({t:'startRound',seed,order,startIdx});
};
$('#reveal').onclick = ()=> publish({t:'reveal'});
$('#force-final').onclick=()=>{
  const alive=Array.from(S.alive);
  if(alive.length!==2) return alert('Finale kr√¶ver 2 spillere');
  publish({t:'final',seed:crypto.randomUUID(),first:alive[rnd(2)]});
};
$('#show-hand').onclick=()=>{
  const label = S.localHand.map((c,i)=> (c==='death'?'DEATH':'Life')).join(' , ');
  alert('Dine kort: ' + (label || '(ingen)'));
};
$('#confirm-swap').onclick = confirmGiveBack;

/* ====== Render ====== */
function renderAll(){
  renderPlayers();
  renderTable();
  $('#ui-phase').textContent=({lobby:'Lobby',round:'Runde',reveal:'Afsl√∏ring',final:'Finale',end:'Slut'})[S.phase]||S.phase;
  $('#ui-turn').textContent=S.turnStage==='idle'?'‚Äî':(
    S.turnStage==='chooseTarget'?'V√¶lg modstander':
    S.turnStage==='chooseOppCard'?'V√¶lg modstanders kort':
    S.turnStage==='chooseGiveBack'?'V√¶lg dit kort (byttes)':'‚Äî'
  );
  potBadge.textContent=String(S.pot); potBadgeSm.textContent=String(S.pot);
  $('#confirm-swap').disabled = !(S.turnStage==='chooseGiveBack' && S.selectedIdx!==null);
}
function renderPlayers(){
  playersList.innerHTML='';
  const ids=S.alive.size? Array.from(S.alive):Object.keys(S.presence);
  ids.forEach(id=>{
    const li=document.createElement('li');
    const alive=S.alive.has(id);
    li.className='flex items-center justify-between px-3 py-2 rounded-lg bg-slate-950/50 border border-slate-800';
    li.innerHTML=`<span>${S.presence[id]?.name||'?'}${S.presence[id]?.host?' <span class="text-amber-400 text-xs">(host)</span>':''}${S.bots[id]?' <span class="text-xs text-fuchsia-400">(NPC)</span>':''}</span>
                  <span class="text-xs ${alive?'text-emerald-400':'text-rose-400'}">${alive?'i spil':'ude'}</span>`;
    playersList.appendChild(li);
  });
}
function renderTable(){
  const ids=S.alive.size? Array.from(S.alive):Object.keys(S.presence);
  table.innerHTML='';
  const n=ids.length||4; const r=220;
  ids.forEach((id,i)=>{
    const angle=(i/n)*Math.PI*2 - Math.PI/2;
    const x=260+Math.cos(angle)*r, y=260+Math.sin(angle)*r;
    const seat=document.createElement('div'); seat.className='seat'; seat.style.left=x+'px'; seat.style.top=y+'px';

    // Header
    const isTurn = (S.phase==='round' && S.seats[S.turnIdx]===id);
    seat.insertAdjacentHTML('afterbegin', `<div class="text-center mb-1 ${isTurn?'text-amber-300':''}">${S.presence[id]?.name||'?'}</div>`);

    // Row of two cards (other players as backsides)
    const row=document.createElement('div'); row.className='flex items-center justify-center gap-2';

    if(id===S.me.id){
      // show my real hand (2 or 3 during swap)
      S.localHand.forEach((card, idx)=>{
        const c=document.createElement('div'); c.className='card';
        if(card==='life') c.classList.add('life'); if(card==='death') c.classList.add('death');
        if(S.phase==='round' && S.seats[S.turnIdx]===id && S.turnStage==='chooseGiveBack'){
          // only allow selecting one of your *original* two (not the just-taken one)
          const isForbidden = (S.pending.receivedIndex===idx);
          c.classList.add('me-turn');
          if(S.selectedIdx===idx) c.classList.add('selected');
          c.onclick = ()=>{
            if(isForbidden){ alert('Du skal give et af dine oprindelige kort tilbage ‚Äì ikke det du lige tog.'); return; }
            S.selectedIdx=idx; renderAll();
          };
        }
        row.appendChild(c);
      });
    } else {
      // opponent seat: backsides, but clickable when selecting target or their card
      // a wrapper for each backside to click L/R
      for(let k=0;k<2;k++){
        const c=document.createElement('div'); c.className='card';
        // Selecting target?
        if(S.phase==='round' && S.seats[S.turnIdx]===S.me.id){
          if(S.turnStage==='chooseTarget'){
            c.classList.add('me-turn','targetable');
            c.title = `V√¶lg ${S.presence[id]?.name||'spiller'}`;
            c.onclick = ()=> { if(id===S.me.id) return; S.pending.targetId=id; S.turnStage='chooseOppCard'; renderAll(); };
          } else if(S.turnStage==='chooseOppCard' && S.pending.targetId===id){
            c.classList.add('me-turn','selected');
            c.title = k===0?'Tag venstre kort':'Tag h√∏jre kort';
            c.onclick = ()=> chooseOppCardIndex(k);
          }
        }
        row.appendChild(c);
      }
    }

    seat.appendChild(row);
    table.appendChild(seat);
  });
}

/* ====== Pot ====== */
function recalcPot(){ const active=Array.from(S.alive).length; S.pot=active*(S.stake||0); renderAll(); }

/* ====== Runde: start/deal ====== */
function startRoundApply(seed, order, startIdx){
  S.seats=order.slice(); S.startIdx=startIdx%S.seats.length; S.turnIdx=S.startIdx;
  S.phase='round'; S.passLapCount=0; S.turnStage='idle'; S.selectedIdx=null; S.pending={targetId:null,oppIdx:null,receivedIndex:null};
  log('üÉè Ny runde ‚Äì stj√¶l & byt.');

  // Deal: total 2 per player, exactly 1 death overall
  const total=S.seats.length*2;
  const deck=Array(total).fill('life'); deck[rnd(total)]='death';
  S.hands={}; S.counts={}; S.localHand=[];
  S.seats.forEach(id=> S.counts[id]=0);
  for(let i=0;i<S.seats.length;i++){
    for(let c=0;c<2;c++){
      const card=deck.splice(rnd(deck.length),1)[0];
      const id=S.seats[i];
      if(id===S.me.id) receiveCard(card);
      else if(S.bots[id]) botReceiveCard(id,card);
      else sendCardToThief(/*from*/null, id, card); // initial deal to human via p2p (reuse path)
    }
  }
  publish({t:'enableTurn', id:S.seats[S.turnIdx]});
  recalcPot(); renderAll();
}

/* ====== Card IO ====== */
function receiveCard(card){ S.localHand.push(card); S.hands[S.me.id]=S.localHand; S.counts[S.me.id]=(S.counts[S.me.id]||0)+1; renderAll(); }
function botReceiveCard(id, card){ S.hands[id]=(S.hands[id]||[]); S.hands[id].push(card); S.counts[id]=(S.counts[id]||0)+1; }

function thiefReceiveCard(card){
  // I (thief) received opponent's card: append as new last index, remember index to forbid giving it back
  const newIdx = S.localHand.length;
  S.localHand.push(card);
  S.pending.receivedIndex = newIdx;
  S.turnStage='chooseGiveBack';
  log(`Du modtog modstanderens kort. V√¶lg nu √©t af dine oprindelige kort at give tilbage.`);
  renderAll();
}
function targetReceiveCard(card, targetId){
  // I (target) received thief's give-back
  if(targetId!==S.me.id) return; // ignore if routed elsewhere
  S.localHand.push(card);
  renderAll();
}

/* ====== Turn flow ‚Äì my turn ====== */
function beginMyTurn(){
  if(S.phase!=='round') return;
  S.turnStage='chooseTarget'; S.pending={targetId:null,oppIdx:null,receivedIndex:null}; S.selectedIdx=null;
  log('‚ú® Din tur: v√¶lg en modstander.');
  renderAll();
}
function chooseOppCardIndex(idx){
  if(!(S.turnStage==='chooseOppCard' && S.pending.targetId)) return;
  S.pending.oppIdx = idx;
  // Ask target to send their card (secret) to me
  publish({t:'askOppCard', thief:S.me.id, target:S.pending.targetId, idx});
  log(`Du v√¶lger ${S.presence[S.pending.targetId]?.name||'?'}s ${idx===0?'venstre':'h√∏jre'} kort...`);
}
function confirmGiveBack(){
  if(!(S.turnStage==='chooseGiveBack' && S.selectedIdx!==null)) return;
  if(S.selectedIdx===S.pending.receivedIndex){ alert('Du m√• ikke give det kort tilbage, du lige tog.'); return; }
  const give = S.localHand[S.selectedIdx];
  // Remove selected give-back from my hand:
  S.localHand.splice(S.selectedIdx,1);
  if(S.pending.receivedIndex > S.selectedIdx) S.pending.receivedIndex--; // shift index if needed
  // Send to target:
  sendCardToTarget(S.me.id, S.pending.targetId, give);
  log(`Du gav et kort tilbage til ${S.presence[S.pending.targetId]?.name||'modstander'}.`);
  // Turn done
  S.turnStage='idle'; S.selectedIdx=null; S.pending={targetId:null,oppIdx:null,receivedIndex:null};
  publish({t:'turnDone'});
  renderAll();
}

/* ====== Turn flow ‚Äì events anyone listens to ====== */
// Target must send its chosen card secretly to thief and remove it from own hand
function onAskOppCard(thiefId, targetId, idx){
  if(S.bots[targetId]){
    // bot target: take idx from bot hand
    const h=S.hands[targetId]||[];
    const card=h.splice(idx,1)[0];
    sendCardToThief(targetId, thiefId, card);
    publish({t:'gotOppCard', thief:thiefId});
    return;
  }
  if(targetId!==S.me.id) return;
  const h=S.localHand;
  if(!h.length) return;
  const card = h.splice(Math.max(0,Math.min(idx,h.length-1)),1)[0];
  sendCardToThief(S.me.id, thiefId, card);
  log(`üîª ${S.presence[thiefId]?.name||'Spiller'} tog √©t af dine kort.`);
  renderAll();
  publish({t:'gotOppCard', thief:thiefId});
}
function onGotOppCard(thiefId){
  if(thiefId===S.me.id){
    // my UI will be updated by thiefReceiveCard via p2p already
  }
}

/* ====== Advance to next turn & laps ====== */
function applyTurnAdvance(){
  // next seat turn
  const prev=S.turnIdx;
  S.turnIdx=(S.turnIdx+1)%S.seats.length;

  // lap end?
  const lapEnded = (S.turnIdx===S.startIdx);
  if(lapEnded){
    S.passLapCount++;
    log(`üîÅ Omgang ${S.passLapCount}/${S.passTarget} fuldf√∏rt.`);
    if(S.passLapCount>=S.passTarget){ S.phase='reveal'; renderAll(); log('üîî Omgange n√•et ‚Äì klar til afsl√∏ring.'); return; }
  }
  publish({t:'enableTurn', id:S.seats[S.turnIdx]});
  renderAll();
  maybeBotTakeTurn(S.seats[S.turnIdx]);
}

/* ====== Afsl√∏ring / Elimination ====== */
function doReveal(){
  if(S.phase!=='reveal') return;
  if((S.hands[S.me.id]||S.localHand).includes('death')) publish({t:'elim', id:S.me.id});
  Object.keys(S.bots).forEach(id=>{ if((S.hands[id]||[]).includes('death')) publish({t:'elim', id}); });
}
function eliminate(id){
  if(!S.alive.has(id)) return;
  S.alive.delete(id);
  log(`‚ò†Ô∏è ${S.presence[id]?.name||id} er ude (Death).`);
  const alive=Array.from(S.alive);
  if(alive.length===1) publish({t:'end', winner:alive[0]});
  else if(alive.length===2) publish({t:'final', seed:crypto.randomUUID(), first:alive[rnd(2)]});
  else { S.phase='lobby'; log('V√¶rten kan starte n√¶ste runde.'); }
  recalcPot(); renderAll();
}

/* ====== Finale (samme som f√∏r) ====== */
let F={deck:[], face:[], turn:null};
function startFinal(seed, first){
  S.phase='final'; renderAll(); log('üèÅ Finale! 8 kort i cirkel.');
  F.deck=Array(8).fill('life'); F.deck[rnd(8)]='death'; F.face=Array(8).fill(false); F.turn=first;
  if(F.turn===S.me.id) finalPickPrompt(); else if(S.bots[F.turn]) botFinalPick(F.turn);
}
function finalPickPrompt(){ const s=prompt('Finale: v√¶lg felt 1‚Äì8'); const idx=Math.max(1,Math.min(8,parseInt(s||'1',10)))-1; const card=F.deck[idx]; publish({t:'finalPick', id:S.me.id, idx, card}); }
function finalApplyPick(id, idx, card){
  if(F.face[idx]) return; F.face[idx]=true;
  log(`üé≤ ${S.presence[id]?.name||id} trak ${card==='death'?'DEATH':'Life'}.`);
  if(card==='death'){ const loser=id; const alive=Array.from(S.alive); const winner=alive.find(x=>x!==loser)||S.me.id; publish({t:'end',winner}); return; }
  const alive=Array.from(S.alive); const other=alive.find(x=>x!==id);
  F.turn=other; if(other===S.me.id) finalPickPrompt(); else if(S.bots[other]) botFinalPick(other);
}
function endGame(winner){ S.phase='end'; renderAll(); const name=S.presence[winner]?.name||'Ukendt'; log(`üèÜ ${name} vinder og tager ${S.pot} guld!`); alert(`${name} vinder ${S.pot} guld!`); }

/* ====== Bots ====== */
function maybeBotTakeTurn(id){
  if(S.phase!=='round' || !S.bots[id]) return;
  // Bot plays: choose random live target != id, choose index, then choose give-back (prefer to dump death)
  setTimeout(()=>{
    const lives=Array.from(S.alive).filter(x=>x!==id);
    const target = lives[rnd(lives.length)];
    const idx = rnd(2);
    // take target idx
    const thand = S.hands[target]||[];
    const taken = thand.splice(idx,1)[0] || (Math.random()<0.125?'death':'life'); // fallback
    // give back from its originals (prefer give death if it has)
    const my = S.hands[id]||[];
    // bot keeps the taken card; must give one original back
    const originalChoices=my; // my contains only originals at this point
    let giveIdx = originalChoices.findIndex(c=>c==='death');
    if(giveIdx<0) giveIdx = 0;
    const give = originalChoices.splice(giveIdx,1)[0] || 'life';
    // now bot hand becomes: originals minus one + taken card
    my.push(taken);
    S.hands[id]=my;
    // target receives give
    const tgt = S.hands[target]||[]; tgt.push(give); S.hands[target]=tgt;
    log(`ü§ñ ${S.presence[id]?.name||'NPC'} byttede med ${S.presence[target]?.name||'spiller'}.`);
    publish({t:'turnDone'});
  }, 600+rnd(900));
}

/* ====== Misc ====== */
function setupNames(){ S.me.name=$('#my-name').value||'DM'; }
</script>
</body>
</html>
