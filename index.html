<!doctype html>
<html lang="da">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Dead Man‚Äôs Draw ‚Äì D&D Tavern</title>
  <meta name="description" content="Tavern-style social deduction kortspil til D&D-bordet. 4 spillere, pot med guld, eliminer den der ender med Death." />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Rundt bord layout */
    .tavern {
      background: radial-gradient(1200px 600px at 50% 20%, rgba(255,220,160,.08), transparent),
                  radial-gradient(600px 300px at 10% 10%, rgba(255,255,255,.05), transparent),
                  #0b0f17;
      min-height: 100vh;
    }
    .wood {
      background: radial-gradient(closest-side, rgba(0,0,0,.2), rgba(0,0,0,.5)),
                  repeating-conic-gradient(from 0deg, #5d3a1a 0 10deg, #6f4621 10deg 20deg);
      border: 8px solid #3d2a13;
      box-shadow: 0 0 40px rgba(0,0,0,.6) inset, 0 10px 30px rgba(0,0,0,.6);
    }
    .circle {
      position: relative;
      width: 520px; height: 520px; border-radius: 50%;
      margin: 0 auto;
    }
    .seat {
      position: absolute; width: 120px; height: 120px; transform: translate(-50%,-50%);
    }
    .seat .card {
      width: 44px; height: 64px; border-radius: 6px; border: 2px solid rgba(0,0,0,.6);
      box-shadow: 0 2px 8px rgba(0,0,0,.5);
      background: linear-gradient(135deg,#222,#333);
    }
    .seat .card.life { background: linear-gradient(135deg,#164e63,#0e7490); }
    .seat .card.death { background: linear-gradient(135deg,#3f1d1d,#7f1d1d); }
    .glow { box-shadow: 0 0 0 2px rgba(255,215,0,.6), 0 0 16px rgba(255,215,0,.4); }
    .dim  { filter: contrast(.9) brightness(.85); }
    .token {
      width: 28px; height: 28px; border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffe38a, #b88700);
      border: 2px solid #4a3406;
      box-shadow: 0 1px 6px rgba(0,0,0,.6);
      display: inline-flex; align-items:center; justify-content:center;
      font-weight:700; font-size:12px; color:#3a2a02;
    }
    .scrollbox { scrollbar-color: #334155 transparent; }
    .qr { image-rendering: pixelated; }
    @media (max-width: 640px){
      .circle { width: 92vw; height: 92vw; }
      .seat { width: 28vw; height: 28vw; }
    }
  </style>
</head>
<body class="tavern text-slate-100">
  <div class="max-w-6xl mx-auto p-4 md:p-6">
    <header class="mb-4 md:mb-6 flex items-center justify-between">
      <div>
        <h1 class="text-2xl md:text-3xl font-extrabold tracking-tight">The Dead Man‚Äôs Draw <span class="text-amber-400">‚Äì D&D Tavern</span></h1>
        <p class="text-slate-300 text-sm md:text-base">4 spillere ‚Äì undg√• <span class="text-rose-400 font-semibold">Death</span>. Vind potten i guld.</p>
      </div>
      <div class="hidden sm:flex items-center gap-3">
        <div class="token" title="Potte" id="pot-badge">0</div>
        <span class="text-xs text-slate-400">guld i potten</span>
      </div>
    </header>

    <!-- Setup -->
    <section class="grid md:grid-cols-2 gap-4 mb-5">
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-4">
        <h2 class="font-semibold mb-3">1) Forbindelse</h2>
        <div class="grid gap-2">
          <label class="text-sm">Supabase URL</label>
          <input id="sb-url" class="px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" placeholder="https://YOUR-PROJECT.supabase.co" />
          <label class="text-sm mt-1">Supabase Anon Key</label>
          <input id="sb-key" class="px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" placeholder="ey..." />
          <div class="flex gap-2 mt-2">
            <button id="btn-init" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500">Initialis√©r</button>
            <button id="btn-make-room" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500">Opret rum</button>
            <input id="room-code" class="flex-1 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" placeholder="RUMKODE" />
            <button id="btn-join" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500">Join</button>
          </div>
          <div class="grid grid-cols-2 gap-2 mt-2">
            <input id="player-name" class="px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" placeholder="Dit navn" />
            <button id="btn-qr" class="px-3 py-2 rounded-xl bg-slate-700">Vis QR link</button>
          </div>
        </div>
        <p class="text-xs text-slate-400 mt-2">N√∏gler gemmes kun i din browser.</p>
      </div>

      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-4">
        <h2 class="font-semibold mb-3">2) Indsats & spilkontrol</h2>
        <div class="grid sm:grid-cols-3 gap-2">
          <div class="sm:col-span-1">
            <label class="text-sm">Indsats pr. spiller</label>
            <div class="flex gap-2 mt-1">
              <input id="stake" type="number" min="0" value="10" class="w-24 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700" />
              <button id="btn-set-stake" class="px-3 py-2 rounded-xl bg-amber-600 hover:bg-amber-500">S√¶t</button>
            </div>
            <p class="text-xs text-slate-400 mt-1">Puljen opdateres automatisk for aktive spillere.</p>
          </div>
          <div class="sm:col-span-2">
            <label class="text-sm">V√¶rt (host) kontrol</label>
            <div class="flex flex-wrap gap-2 mt-1">
              <button id="btn-start-round" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500">Start runde</button>
              <button id="btn-reveal" class="px-3 py-2 rounded-xl bg-rose-700 hover:bg-rose-600">Afsl√∏r & eliminer</button>
              <button id="btn-final" class="px-3 py-2 rounded-xl bg-fuchsia-700 hover:bg-fuchsia-600">Tving finale (1v1)</button>
              <span class="text-xs text-slate-400 self-center">Kun v√¶rten kan trykke.</span>
            </div>
          </div>
        </div>
        <div class="mt-3 text-sm">
          Rum: <span id="ui-room" class="font-mono">‚Äî</span> ¬∑
          Din rolle: <span id="ui-role" class="px-2 py-1 rounded-full bg-slate-800 border border-slate-700">Observat√∏r</span> ¬∑
          Fase: <span id="ui-phase" class="px-2 py-1 rounded-full bg-slate-800 border border-slate-700">Lobby</span>
        </div>
      </div>
    </section>

    <!-- Bord + sidebar -->
    <section class="grid lg:grid-cols-3 gap-4">
      <div class="lg:col-span-2 rounded-3xl wood p-6">
        <div class="circle" id="table">
          <!-- seats placeres dynamisk -->
        </div>
        <div class="mt-3 flex flex-wrap items-center gap-2">
          <button id="btn-pass-left" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50" disabled>Giv venstre (v√¶lg kort)</button>
          <button id="btn-show-cards" class="px-4 py-2 rounded-xl bg-slate-700">Se mine kort (lokalt)</button>
          <div class="ml-auto flex items-center gap-2 sm:hidden">
            <div class="token" id="pot-badge-sm">0</div><span class="text-xs text-slate-300">guld i potten</span>
          </div>
        </div>
      </div>

      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-4">
        <h3 class="font-semibold">Spillere</h3>
        <ul id="players" class="mt-2 space-y-2 text-sm"></ul>

        <h3 class="font-semibold mt-4">Log</h3>
        <div id="log" class="scrollbox mt-2 h-60 overflow-auto text-xs bg-slate-950/40 border border-slate-800 rounded-xl p-2"></div>

        <h3 class="font-semibold mt-4">QR join</h3>
        <canvas id="qr" width="160" height="160" class="qr bg-white rounded-xl"></canvas>
      </div>
    </section>

    <footer class="mt-8 text-xs text-slate-500">Fan-projekt til hjemmebrug. Ikke tilknyttet TV-formatet. Spil ansvarligt üçª</footer>
  </div>

  <script type="module">
    // --- deps via ESM ---
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
    import Peer from 'https://esm.sh/simple-peer@9.11.1';

    // --- helpers ---
    const $ = s => document.querySelector(s);
    const log = (m) => { const d=document.createElement('div'); d.textContent = `[${new Date().toLocaleTimeString()}] ${m}`; $('#log').appendChild(d); $('#log').scrollTop = $('#log').scrollHeight; };
    const rnd = (n)=>Math.floor(Math.random()*n);
    const persist = {
      save(k,v){ localStorage.setItem(k, JSON.stringify(v)); },
      load(k,def=null){ try{ const v = JSON.parse(localStorage.getItem(k)); return v ?? def; } catch { return def; } }
    };

    // UI refs
    const ui = {
      room: $('#ui-room'), role: $('#ui-role'), phase: $('#ui-phase'),
      potBadge: $('#pot-badge'), potBadgeSm: $('#pot-badge-sm'),
      table: $('#table'), players: $('#players')
    };

    // --- game state ---
    const S = {
      sb:null, channel:null, room:null, isHost:false,
      me: { id: crypto.randomUUID(), name: '' },
      presence: {}, peers: new Map(), // id -> Peer
      stake: 10, pot: 0,
      phase: 'lobby', // lobby | round | reveal | final | end
      seats: [], // circular order of active players (ids)
      startIdx: 0, turnIdx: 0,
      hands: {}, // id -> ['life'|'death', 'life'...], private (only own stored fully)
      // For others: we only store counts; own hand is full info
      counts: {}, // id -> number of cards (2 or 3 mid-turn)
      alive: new Set(), // active players
      localHand: [], // convenience pointer to S.hands[S.me.id]
    };

    // restore inputs
    $('#sb-url').value = persist.load('sb-url','');
    $('#sb-key').value = persist.load('sb-key','');
    $('#player-name').value = persist.load('name','');

    // --- Supabase init / room join ---
    $('#btn-init').onclick = () => {
      const url = $('#sb-url').value.trim(), key = $('#sb-key').value.trim();
      if(!url || !key){ alert('Udfyld Supabase URL + Anon Key'); return; }
      S.sb = createClient(url,key,{ realtime:{ params:{ eventsPerSecond:5 } }});
      persist.save('sb-url',url); persist.save('sb-key',key);
      log('‚úÖ Supabase initialiseret.');
    };

    $('#btn-make-room').onclick = async () => {
      await ensureSB();
      setupName();
      const code = makeRoom(); await join(code,true);
    };

    $('#btn-join').onclick = async () => {
      await ensureSB();
      setupName();
      const code = ($('#room-code').value||'').trim().toUpperCase();
      if(!code){ alert('Indtast rumkode'); return; }
      await join(code,false);
    };

    $('#btn-qr').onclick = () => drawQR(location.href.split('#')[0] + '#' + (S.room||'')); // simple QR

    function setupName(){
      const n = ($('#player-name').value||'').trim(); if(!n){ alert('Skriv dit navn'); throw new Error(); }
      S.me.name = n; persist.save('name',n);
    }

    function makeRoom(){
      const chars='ABCDEFGHJKMNPQRSTUVWXYZ23456789'; let s=''; for(let i=0;i<5;i++) s+=chars[rnd(chars.length)];
      $('#room-code').value = s; return s;
    }

    async function ensureSB(){ if(!S.sb){ alert('Tryk ‚ÄúInitialis√©r‚Äù f√∏rst.'); throw new Error('no sb'); } }

    async function join(code, asHost){
      S.room = code; S.isHost = !!asHost;
      ui.room.textContent = code;
      $('#btn-qr').click();
      $('#btn-pass-left').disabled = true;
      // channel
      S.channel = S.sb.channel(`tavern-${code}`, { config:{ broadcast:{ self:true }, presence:{ key: S.me.id } } });

      // presence
      S.channel.on('presence', {event:'sync'}, () => {
        const st = S.channel.presenceState();
        const list = Object.values(st).flat().map(p=>p.meta);
        S.presence = {}; list.forEach(p=> S.presence[p.id]=p);
        renderPlayers();
        recalcPot();
      });
      S.channel.on('presence', {event:'join'}, ({ newPresences }) => { newPresences.forEach(p=>log(`üîπ ${p.meta.name} joined`)); });
      S.channel.on('presence', {event:'leave'}, ({ leftPresences }) => { leftPresences.forEach(p=>log(`üî∏ ${p.meta.name} left`)); });

      // broadcasts
      S.channel.on('broadcast', {event:'public'}, ({payload}) => onPublic(payload));
      S.channel.on('broadcast', {event:'signal'}, ({payload}) => onSignal(payload));

      // subscribe + track
      await S.channel.subscribe(async (status)=>{
        if(status!=='SUBSCRIBED') return;
        await S.channel.track({ id:S.me.id, name:S.me.name, host:S.isHost });
        S.phase='lobby'; updatePhase();
        log(`Du er ${S.me.name}${S.isHost?' (host)':''}. Del rumkoden: ${S.room}`);
      });

      // auto-join via hash link
      if(location.hash.replace('#','')!==code){ history.replaceState(null,'', '#'+code); }
    }

    // --- Public events ---
    function publishPublic(payload){ S.channel.send({ type:'broadcast', event:'public', payload }); }

    function onPublic(msg){
      if(msg.t==='stake'){ S.stake = msg.v; recalcPot(); if(S.isHost) log(`Indsats sat til ${S.stake} guld.`); }
      if(msg.t==='startRound'){ host_startRound_apply(msg.seed, msg.players, msg.startIdx); }
      if(msg.t==='turn'){ applyTurn(msg.from, msg.to, msg.cardToken); }
      if(msg.t==='youDraw'){ if(msg.to===S.me.id){ receiveSecretCard(msg.card); } }
      if(msg.t==='enableTurn'){ if(msg.id===S.me.id){ enableTurn(); } }
      if(msg.t==='reveal'){ doReveal(); }
      if(msg.t==='elim'){ handleElimination(msg.id); }
      if(msg.t==='final'){ startFinal(msg.seed, msg.first); }
      if(msg.t==='finalDraw'){ finalApplyDraw(msg.id, msg.pickIndex, msg.card); }
      if(msg.t==='end'){ endGame(msg.winner); }
      if(msg.t==='info'){ log(msg.m); }
      renderPlayers();
    }

    // --- WebRTC for private messages (cards) ---
    async function ensurePeer(otherId, initiator){
      if(S.peers.has(otherId)) return S.peers.get(otherId);
      const p = new Peer({ initiator, trickle:false });
      p.on('signal', data => S.channel.send({ type:'broadcast', event:'signal', payload:{ from:S.me.id, to:otherId, data } }));
      p.on('connect', ()=> log(`üîó P2P for hemmelige kort med ${S.presence[otherId]?.name||otherId}`));
      p.on('error', e=>console.warn('peer',e));
      p.on('close', ()=> S.peers.delete(otherId));
      S.peers.set(otherId,p);
      if(!initiator){
        // nudge
        S.channel.send({ type:'broadcast', event:'signal', payload:{ from:S.me.id, to:null, data:{type:'hello'} } });
      }
      return p;
    }
    function onSignal({from,to,data}){
      if(data?.type==='hello' && S.isHost){ ensurePeer(from,true); return; }
      if(to && to!==S.me.id) return;
      let p = S.peers.get(from);
      if(!p){ p=new Peer({ initiator:false, trickle:false });
        p.on('signal', d=> S.channel.send({ type:'broadcast', event:'signal', payload:{ from:S.me.id, to:from, data:d } }));
        p.on('connect', ()=> log(`üîó P2P ${S.presence[from]?.name||from}`));
        p.on('error', e=>console.warn('peer',e));
        p.on('close', ()=> S.peers.delete(from));
        S.peers.set(from,p);
      }
      try{ p.signal(data); }catch(e){ console.warn('signal err',e); }
    }
    async function sendSecret(toId, obj){
      const p = await ensurePeer(toId, S.isHost); // host init
      p.send(JSON.stringify(obj));
    }
    // receive secret
    for (const [evt] of [['message']]) {} // no-op to please bundlers
    // simple inbox
    S.secretBuf = '';
    // hook peers dynamically:
    const origSet = S.peers.set;
    S.peers.set = function(k,v){
      const ret = Map.prototype.set.call(this,k,v);
      v.on('data',(buf)=>{
        try{
          const msg = JSON.parse(buf.toString());
          if(msg.t==='card'){ receiveSecretCard(msg.card); }
        }catch(e){}
      });
      return ret;
    };

    // --- UI actions ---
    $('#btn-set-stake').onclick = () => {
      if(!S.isHost){ alert('Kun v√¶rten kan s√¶tte indsats'); return; }
      const v = Math.max(0, parseInt($('#stake').value||'10',10));
      publishPublic({ t:'stake', v });
    };

    $('#btn-start-round').onclick = () => {
      if(!S.isHost){ alert('Kun v√¶rten'); return; }
      // require exactly 4 at start; men hvis f√¶rre pga elim, forts√¶t (min 3; finale ved 2)
      const active = Object.values(S.presence).filter(p=>!p.spectator).map(p=>p.id);
      if(active.length < 2){ alert('Kr√¶ver mindst 2 spillere'); return; }
      if(active.length===2){ publishPublic({t:'final', seed: crypto.randomUUID(), first: active[rnd(2)]}); return; }
      const seed = crypto.randomUUID();
      const startIdx = rnd(active.length);
      publishPublic({ t:'startRound', seed, players: active, startIdx });
    };

    $('#btn-reveal').onclick = () => { if(S.isHost) publishPublic({ t:'reveal' }); };

    $('#btn-final').onclick = () => {
      if(!S.isHost) return;
      const alive = Array.from(S.alive||new Set(Object.keys(S.presence)));
      if(alive.length!==2){ alert('Finale kr√¶ver 2 spillere'); return; }
      publishPublic({ t:'final', seed: crypto.randomUUID(), first: alive[rnd(2)] });
    };

    $('#btn-pass-left').onclick = () => beginPassSelect();

    $('#btn-show-cards').onclick = () => {
      if(!S.localHand.length){ alert('Du har ingen kort (endnu)'); return; }
      alert('Dine kort: ' + S.localHand.map(x=> x==='death'?'DEATH':'LIFE').join(' , '));
    };

    // --- Render ---
    function renderPlayers(){
      // alive set
      if(!S.alive.size){
        const ids = Object.keys(S.presence);
        ids.forEach(id=>S.alive.add(id));
      }
      // players list
      ui.players.innerHTML = '';
      const ids = Object.values(S.presence).map(p=>p.id);
      ids.forEach(id=>{
        const li = document.createElement('li');
        const me = id===S.me.id;
        const alive = S.alive.has(id);
        li.className = 'flex items-center justify-between px-3 py-2 rounded-lg bg-slate-950/50 border border-slate-800';
        li.innerHTML = `<span>${S.presence[id]?.name||id}${S.presence[id]?.host?' <span class="text-amber-400 text-xs">(host)</span>':''}</span>
                        <span class="text-xs ${alive?'text-emerald-400':'text-rose-400'}">${alive?'i spil':'ude'}</span>`;
        ui.players.appendChild(li);
      });

      // circle seats (alive only)
      const aliveIds = Array.from(S.alive);
      ui.table.innerHTML = '';
      const n = aliveIds.length || 4;
      aliveIds.forEach((id, i)=>{
        const angle = (i / n) * Math.PI*2 - Math.PI/2;
        const r = 210;
        const x = 260 + Math.cos(angle)*r, y = 260 + Math.sin(angle)*r;
        const seat = document.createElement('div');
        seat.className = 'seat';
        seat.style.left = x+'px'; seat.style.top = y+'px';
        seat.innerHTML = `
          <div class="text-center mb-1 ${S.turnIdx===i && S.phase==='round'?'text-amber-300':''}">${S.presence[id]?.name||'?'}</div>
          <div class="flex items-center justify-center gap-2">
            <div class="card ${id===S.me.id && S.localHand[0]==='life'?'life':''} ${id===S.me.id && S.localHand[0]==='death'?'death':''}"></div>
            <div class="card ${id===S.me.id && S.localHand[1]==='life'?'life':''} ${id===S.me.id && S.localHand[1]==='death'?'death':''}"></div>
          </div>`;
        ui.table.appendChild(seat);
      });

      // pot
      ui.potBadge.textContent = String(S.pot);
      ui.potBadgeSm.textContent = String(S.pot);
    }

    function updatePhase(){
      ui.phase.textContent = ({lobby:'Lobby',round:'Runde',reveal:'Afsl√∏ring',final:'Finale',end:'Slut'})[S.phase] || S.phase;
    }

    function recalcPot(){
      const active = Object.values(S.presence).filter(p=>S.alive.has(p.id));
      S.pot = active.length * (S.stake||0);
      renderPlayers();
    }

    // --- Round flow ---
    function host_startRound_apply(seed, players, startIdx){
      // set alive seats to players‚à©alive
      S.seats = players.filter(id=>S.alive.has(id));
      S.startIdx = startIdx % S.seats.length;
      S.turnIdx = S.startIdx;
      S.phase = 'round'; updatePhase();
      log('üÉè Ny runde starter.');
      // deal: 2 pr spiller, med pr√¶cis 1 death i hele bunken
      const total = S.seats.length * 2;
      const deck = Array(total).fill('life'); deck[rnd(total)] = 'death';
      // clear hands
      S.hands = {}; S.counts = {};
      S.seats.forEach(id=>{ S.counts[id]=0; if(id===S.me.id){ S.localHand=[]; } });
      // deal 2 til hver (via private)
      for(let i=0;i<S.seats.length;i++){
        for(let c=0;c<2;c++){
          const card = deck.popAt ? deck.popAt(rnd(deck.length)) : deck.splice(rnd(deck.length),1)[0];
          const id = S.seats[i];
          if(id===S.me.id) { S.localHand.push(card); S.hands[id]=S.localHand; }
          else { sendSecret(id,{ t:'card', card }); }
          S.counts[id] = (S.counts[id]||0)+1;
        }
      }
      publishPublic({ t:'info', m:`Startspiller: ${S.presence[S.seats[S.startIdx]]?.name||'?'}` });
      // enable first turn
      publishPublic({ t:'enableTurn', id: S.seats[S.turnIdx] });
      renderPlayers();
    }

    // receive a secret card (private)
    function receiveSecretCard(card){
      S.localHand.push(card);
      S.hands[S.me.id] = S.localHand;
      S.counts[S.me.id] = (S.counts[S.me.id]||0)+1;
      renderPlayers();
    }

    function enableTurn(){
      if(S.phase!=='round') return;
      if(S.seats[S.turnIdx]===S.me.id){
        $('#btn-pass-left').disabled = false;
        log('‚ú® Din tur: v√¶lg et af dine kort og giv til venstre.');
      }
    }

    function beginPassSelect(){
      if(S.seats[S.turnIdx]!==S.me.id) return;
      if(S.localHand.length<1){ alert('Du har ingen kort'); return; }
      // v√¶lg hvilket kort at sende
      const choice = (S.localHand.length===1) ? 0 :
        (confirm('Tryk OK for at give dit f√∏rste kort, Annuller for at give det andet.') ? 0 : 1);
      const card = S.localHand.splice(choice,1)[0];
      S.counts[S.me.id] = (S.counts[S.me.id]||0)-1;
      // send til venstre
      const toIdx = (S.turnIdx + 1) % S.seats.length;
      const toId = S.seats[toIdx];
      publishPublic({ t:'turn', from:S.me.id, to:toId, cardToken: crypto.randomUUID() });
      sendSecret(toId, { t:'card', card });
      $('#btn-pass-left').disabled = true;
      log(`‚û°Ô∏è Du gav et kort til ${S.presence[toId]?.name||'venstre'}.`);
    }

    function applyTurn(fromId, toId, token){
      // modtager f√•r +1 (selve kortet sendes privat)
      S.counts[toId] = (S.counts[toId]||0)+1;
      // n√¶ste tur
      const atStart = S.turnIdx === S.startIdx;
      S.turnIdx = (S.turnIdx + 1) % S.seats.length;
      // Den der gav, har midlertidigt 1 kort ‚Äì n√¶ste giver videre osv.
      // Runde slutter n√•r startspilleren modtager fra h√∏jre:
      const rcvFromRight = (toId === S.seats[S.startIdx]) && (S.turnIdx === S.startIdx);
      if(rcvFromRight){
        log('üîî Runden er slut. Klar til afsl√∏ring.');
        S.phase = 'reveal'; updatePhase();
      }else{
        publishPublic({ t:'enableTurn', id: S.seats[S.turnIdx] });
      }
      renderPlayers();
    }

    function doReveal(){
      if(S.phase!=='reveal'){ log('‚è≥ Ikke i afsl√∏ringsfase.'); return; }
      // Hver spiller tjekker egne kort. Den der har 'death' elimineres.
      const iHaveDeath = (S.hands[S.me.id]||S.localHand).includes('death');
      if(iHaveDeath){ publishPublic({ t:'elim', id: S.me.id }); }
      else { publishPublic({ t:'info', m: `${S.me.name} overlevede.` }); }
    }

    function handleElimination(id){
      if(!S.alive.has(id)) return;
      const name = S.presence[id]?.name||id;
      S.alive.delete(id);
      log(`‚ò†Ô∏è ${name} havde DEATH og er ude!`);
      // n√¶ste runde / finale
      const alive = Array.from(S.alive);
      if(alive.length===1){
        publishPublic({ t:'end', winner: alive[0] });
      }else if(alive.length===2){
        publishPublic({ t:'final', seed: crypto.randomUUID(), first: alive[rnd(2)] });
      }else{
        // ny runde ‚Äì v√¶rten trykker ‚ÄúStart runde‚Äù (s√• man kan snakke/bluffe)
        S.phase = 'lobby'; updatePhase();
        publishPublic({ t:'info', m:'V√¶rten kan starte n√¶ste runde.' });
      }
      recalcPot();
      renderPlayers();
    }

    // --- Finale (8 kort i cirkel, skiftevis tr√¶k) ---
    let finalDeck = []; let finalFace = []; let finalTurn = null;
    function startFinal(seed, firstId){
      const alive = Array.from(S.alive);
      if(alive.length!==2){
        S.alive = new Set(alive.slice(0,2)); // sikkerhed
      }
      S.phase='final'; updatePhase();
      log('üèÅ Finale! 8 kort i cirkel. Tr√¶k skiftevis.');
      // byg 8 kort (7 life + 1 death), bland
      finalDeck = Array(8).fill('life'); finalDeck[rnd(8)]='death';
      finalFace = Array(8).fill(false);
      finalTurn = firstId;
      publishPublic({ t:'info', m:`${S.presence[firstId]?.name||'?'} tr√¶kker f√∏rst.` });
      if(finalTurn===S.me.id) enableFinalPick();
      renderPlayers();
    }

    function enableFinalPick(){
      // v√¶lg et indeks 0..7
      const pick = prompt('Finale: v√¶lg et felt 1-8 at tr√¶kke (tallet gemmes og bruges ‚Äì ingen kort vises f√∏r efter). Skriv fx 3');
      const idx = Math.max(1, Math.min(8, parseInt(pick||'1',10))) - 1;
      const card = finalDeck[idx];
      publishPublic({ t:'finalDraw', id: S.me.id, pickIndex: idx, card });
    }

    function finalApplyDraw(id, idx, card){
      if(finalFace[idx]) return; // allerede taget
      finalFace[idx] = true;
      log(`üé≤ ${S.presence[id]?.name||id} trak ${card==='death'?'DEATH':'Life'}.`);
      if(card==='death'){
        // tr√¶kker d√∏d ‚Üí taber, modstander vinder
        const loser = id;
        const winner = Array.from(S.alive).find(x=>x!==loser) || S.me.id;
        publishPublic({ t:'end', winner });
        return;
      }
      // skift tur
      const other = Array.from(S.alive).find(x=>x!==id);
      finalTurn = other;
      if(finalTurn===S.me.id) enableFinalPick();
    }

    function endGame(winnerId){
      S.phase='end'; updatePhase();
      const name = S.presence[winnerId]?.name || 'Ukendt';
      log(`üèÜ ${name} vandt og tager ${S.pot} guld!`);
      alert(`${name} vinder ${S.pot} guld!`);
    }

    // --- tiny QR (no deps) ---
    function drawQR(text){
      const c = $('#qr'); const g = c.getContext('2d');
      // super simpel "QR": vi skriver bare URL‚Äôen ‚Äì for rigtige QR brug en lib; men dette virker som ‚Äúscan text‚Äù
      g.fillStyle='#fff'; g.fillRect(0,0,c.width,c.height);
      g.fillStyle='#000'; g.font='12px monospace'; wrapText(g,text,8,20,144,14);
    }
    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' '); let line='';
      for(let n=0;n<words.length;n++){
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n>0) { ctx.fillText(line, x, y); line = words[n] + ' '; y += lineHeight; }
        else { line = testLine; }
      }
      ctx.fillText(line, x, y);
    }

    // polyfill for random pop
    if(!Array.prototype.popAt){
      Array.prototype.popAt = function(i){ return this.splice(i,1)[0]; }
    }
  </script>
</body>
</html>
